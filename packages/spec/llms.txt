# @objectstack/spec Context for AI Agents

> **SYSTEM NOTE**: This file provides a high-level summary of the ObjectStack Protocol to help LLMs understand the codebase structure and intent.

## 1. Architecture Overview (The "Three-Layer Model")

ObjectStack is a metadata-driven "Post-SaaS Operating System".
It is divided into three layers, reflected in the import paths:

### Layer 1: ObjectQL (`@objectstack/spec/data`)
**The Business Kernel**. Defines "What Data Exists".
- **`ObjectSchema`**: Defines database tables (postgres/mongo agnostic).
- **`FieldSchema`**: Defines columns with types (`text`, `number`, `lookup`, `formula`).
- **`QuerySchema`**: A JSON-based AST for querying data (replaces SQL).
- **`DriverInterface`**: The contract for database adapters.

### Layer 2: ObjectOS (`@objectstack/spec/system` & `@objectstack/spec/api`)
**The Runtime Kernel**. Defines "How System Operates".
- **`ManifestSchema`**: `objectstack.config.ts` configuration.
- **`IdentitySchema`**: Users, Roles, and Authentication.
- **`EventSchema`**: System bus and Webhooks.
- **`EndpointSchema`**: API Gateway configuration.

### Layer 3: ObjectUI (`@objectstack/spec/ui`)
**The Presentation Layer**. Defines "How Users Interact".
- **`AppSchema`**: Navigation menus and branding.
- **`ViewSchema`**: Layouts for data (Grid, Kanban, Calendar).
- **`ActionSchema`**: Buttons and triggers.

---

## 2. Coding Patterns (Zod First)

All definitions are virtually **Zod Schemas**.
- **Configuration Keys**: `camelCase` (e.g., `maxLength`, `referenceFilters`).
- **Data Values**: `snake_case` (e.g., `object: 'project_task'`, `type: 'lookup'`).

### Example: Defining an Object
```typescript
import { ObjectSchema } from '@objectstack/spec/data';

// Describes a "Task" object
const taskObject = {
  name: 'project_task',  // snake_case table name
  label: 'Project Task',
  fields: {
    status: { type: 'select', options: ['todo', 'done'] },
    priority: { type: 'number', defaultValue: 0 }
  }
};
```

### Example: Building a Query
```typescript
import { QuerySchema } from '@objectstack/spec/data';

// JSON-based SQL alternative
const query = {
  object: 'project_task',
  filters: [
    ['status', '=', 'todo'],
    'and',
    ['priority', '>', 1]
  ],
  sort: [{ field: 'created_at', order: 'desc' }],
  top: 10
};
```

---

## 3. Key exports by Namespace

### `import * as Data from '@objectstack/spec/data'`
- `ObjectSchema`, `FieldSchema`: Logic & Storage definition.
- `QuerySchema`, `FilterSchema`: Data retrieval AST.
- `DriverInterface`, `DatasourceSchema`: Database connectivity.
- `WorkflowSchema`, `FlowSchema`: Automation logic.

### `import * as UI from '@objectstack/spec/ui'`
- `ViewSchema`: `type: 'grid' | 'kanban' | 'calendar'`.
- `FormSchema`: `layout: 'simple' | 'tabbed'`.
- `DashboardSchema`: Widget composition.

### `import * as System from '@objectstack/spec/system'`
- `PluginSchema`: Module lifecycle.
- `EventSchema`: Pub/Sub definitions.
- `PolicySchema`: Security rules.

---

## 4. Implementing the Protocol (Engine Devs)

If you are building an ObjectQL engine or Driver in another repository:

### ObjectQL Implementation (Data Layer)
*Reference: `node_modules/@objectstack/spec/prompts/implement-objectql.md`*

Use `z.infer` to derive types directly from the protocol. Do not manually re-declare interfaces.

```typescript
import { DriverInterfaceSchema, type DriverInterface } from '@objectstack/spec/data';
// ...
```

### ObjectOS Implementation (System Layer)
*Reference: `node_modules/@objectstack/spec/prompts/implement-objectos.md`*

The Runtime Kernel must be bootstrapped from the Manifest.

```typescript
import { ManifestSchema, IdentitySchema } from '@objectstack/spec/system';
import { type RequestEnvelope } from '@objectstack/spec/api';

// 1. Boot: Validate Config
const config = ManifestSchema.parse(rawConfig);

// 2. Runtime: Validate Identity
function handleRequest(user: z.infer<typeof IdentitySchema>) { ... }
```

### ObjectUI Implementation (View Layer)
*Reference: `node_modules/@objectstack/spec/prompts/implement-objectui.md`*

The UI must be Server-Driven (SDUI), rendering structures defined by the protocol.

```typescript
import { ViewSchema, ActionSchema } from '@objectstack/spec/ui';

// ✅ Valid: Components accept Schema Props
function GridView({ config }: { config: z.infer<typeof ViewSchema> }) {
  // Render based on config.columns, config.filters...
}
```

### ObjectAI Implementation (Intelligence Layer)
*Reference: `node_modules/@objectstack/spec/prompts/implement-objectai.md`*

AI Agents and RAG pipelines must be schema-aware and permission-safe.

```typescript
import { AgentSchema, RAGPipelineSchema } from '@objectstack/spec/ai';

// Agents are configured via Protocol, not arbitrary prompts
const supportAgent = AgentSchema.parse({
  role: 'support',
  tools: ['search_knowledge_base', 'create_ticket']
});
```

### 1. Strict Type Compliance
Use `z.infer` to derive types directly from the protocol. Do not manually re-declare interfaces.

```typescript
import { DriverInterfaceSchema, type DriverInterface } from '@objectstack/spec/data';
import { z } from 'zod';

// ✅ CORRECT: Implementing the interface strictly
export class PostgresDriver implements DriverInterface {
  name = 'postgres';
  version = '1.0.0';
  supports = { transactions: true, ... };
  
  // Implementation matches the Zod schema exactly
  async find(object: string, query: z.infer<typeof QuerySchema>) {
    // ...
  }
}
```

### 2. Runtime Validation
The engine **MUST** validate inputs against the Zod schemas before processing.

```typescript
import { ObjectSchema } from '@objectstack/spec/data';

function registerObject(rawConfig: unknown) {
  // CRITICAL: Parse strictly throws if protocol is violated
  const config = ObjectSchema.parse(rawConfig);
  // ... proceed
}
```
