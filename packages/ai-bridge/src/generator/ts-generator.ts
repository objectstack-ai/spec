import { FieldType } from '@objectstack/spec/data';

// Determine if we can import ObjectSchema directly or if we treat inputs as generic JSON
// For utility purposes, we often process JSON objects that might not be fully instantiated ObjectSchema types yet.
// However, we should strictly align with the FieldType values.

export interface FieldDef {
  type: FieldType; // Strict alignment with Protocol
  label?: string;
  required?: boolean;
  multiple?: boolean;
  options?: Array<{ label: string; value: string } | string>;
  reference?: string;
}

export interface ObjectDef {
  name: string;
  fields: Record<string, FieldDef>;
  description?: string;
  enable?: {
    files?: boolean;
    audit?: boolean;
    trash?: boolean;
  };
}

/**
 * Task 1: Static Type Generator
 */
export function generateTypeScriptDefinition(objects: ObjectDef[]): string {
  const interfaces = objects.map(obj => {
    const fields = Object.entries(obj.fields).map(([fieldName, field]) => {
      let tsType = 'any';
      
      switch (field.type) {
        case 'text':
        case 'textarea':
        case 'email':
        case 'url':
        case 'phone':
        case 'password':
        case 'markdown':
        case 'html':
        case 'richtext':
        case 'image':
        case 'file':
        case 'avatar':
          tsType = 'string';
          break;
          
        case 'select':
          if (field.options && field.options.length > 0) {
             // Handle both string[] and {label, value}[]
             const options = field.options.map(opt => typeof opt === 'string' ? opt : opt.value);
             tsType = options.map(o => `'${o}'`).join(' | ');
          } else {
             tsType = 'string';
          }
          break;

        case 'number':
        case 'currency':
        case 'percent':
        case 'rating':
        case 'slider':
          tsType = 'number';
          break;

        case 'boolean':
          tsType = 'boolean';
          break;

        case 'date':
        case 'datetime':
        case 'time':
          tsType = 'string'; // ISO 8601
          break;

        case 'lookup':
        case 'master_detail':
          // For references, we allow the ID string OR the expanded object (if populated)
          // To be safe for write operations, we focus on the ID string
          // But strict AI typing might benefit from `string`
          tsType = field.reference ? `string | ${toPascalCase(field.reference)}` : 'string';
          break;
        
        case 'formula':
        case 'summary':
        case 'autonumber':
          // Read-only calculated fields
          // Usually number or string depending on return type. Defaulting to any or union for safety
          tsType = 'string | number'; 
          break;

        case 'location':
        case 'geolocation':
        case 'address':
           tsType = '{ latitude: number; longitude: number; } | any';
           break;
           
        default:
          tsType = 'any';
      }

      if (field.multiple) {
        tsType = `(${tsType})[]`;
      }

      const optionalMark = field.required ? '' : '?';
       // Doc comment for the field
       const doc = field.label ? `  /** ${field.label} */\n` : '';
      return `${doc}  ${fieldName}${optionalMark}: ${tsType};`;
    }).join('\n');

    const pascalName = toPascalCase(obj.name);
    
    // Generate Interface
    const interfaceDef = `/**
 * ${obj.description || obj.name}
 */
export interface ${pascalName} {
  _id: string;
${fields}
  // Standard System Fields
  created_on?: string;
  modified_on?: string;
  owner?: string;
}`;

    // Generate ObjectQL Query Helper Types
    const queryTypeDef = `
export type ${pascalName}Filter = {
  [K in keyof ${pascalName}]?: ${pascalName}[K] | { 
    $eq?: ${pascalName}[K]; 
    $ne?: ${pascalName}[K]; 
    $gt?: any; 
    $lt?: any; 
    $in?: ${pascalName}[K][];
    $like?: string;
  };
};

export interface ${pascalName}Query {
  $select?: (keyof ${pascalName})[];
  $filter?: ${pascalName}Filter;
  $sort?: Partial<Record<keyof ${pascalName}, -1 | 1>>;
}
`;

    return interfaceDef + queryTypeDef;
  }).join('\n\n');

  return `// Auto-generated by ObjectStack AI Bridge
// Do not edit manually

${interfaces}
`;
}

function toPascalCase(str: string): string {
  return str.replace(/(^\w|_\w)/g, (m) => m.replace('_', '').toUpperCase());
}
