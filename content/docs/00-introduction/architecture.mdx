---
title: Architecture
description: Understanding the ObjectStack Protocol Architecture - How 11 protocol namespaces collaborate to build the Enterprise Kernel
---

import { Layers, Database, Layout, ShieldCheck, Lock, Cog, Brain, Cloud, Zap } from 'lucide-react';

# Architecture Overview

ObjectStack is not a monolithic framework. It is a composable ecosystem designed around a **Protocol-Driven Architecture**. The system is organized into **11 protocol namespaces**, each responsible for a specific domain.

Each protocol is decoupled and communicates via standard JSON schemas defined with Zod. This allows you to swap out implementations (e.g., swapping the Postgres driver for MongoDB, or the React renderer for Flutter) without breaking the rest of the stack.

## The 11 Protocol Namespaces

ObjectStack is organized into 11 protocol namespaces:

<Cards>
  <Card
    icon={<Database />}
    title="Data Protocol"
    description="Object schema, fields, validation, and queries."
  />
  <Card
    icon={<Cog />}
    title="Driver Protocol"
    description="Database adapters (Postgres, MongoDB, SQLite, etc.)."
  />
  <Card
    icon={<ShieldCheck />}
    title="Permission Protocol"
    description="Object-level, field-level, sharing, and territory rules."
  />
  <Card
    icon={<Layout />}
    title="UI Protocol"
    description="Apps, views, dashboards, reports, and themes."
  />
  <Card
    icon={<Layers />}
    title="System Protocol"
    description="Events, jobs, translations, and audit logging."
  />
  <Card
    icon={<Lock />}
    title="Auth Protocol"
    description="Identity, roles, sessions, and authentication strategies."
  />
  <Card
    icon={<Cog />}
    title="Kernel Protocol"
    description="Plugin lifecycle, manifest, logging, and context."
  />
  <Card
    icon={<Cloud />}
    title="Hub Protocol"
    description="Marketplace, licensing, tenancy, and deployment."
  />
  <Card
    icon={<Brain />}
    title="AI Protocol"
    description="Agents, RAG, NLQ, predictive models, and orchestration."
  />
  <Card
    icon={<Zap />}
    title="API Protocol"
    description="REST contracts, discovery, realtime, and routing."
  />
  <Card
    icon={<Zap />}
    title="Automation Protocol"
    description="Workflows, flows, and webhooks."
  />
</Cards>

## The Three-Layer Architecture

While ObjectStack has 11 protocol namespaces, they are logically grouped into three architectural layers:

### 1. Data Layer (ObjectQL)
**"The Universal Data Protocol"**

The foundation layer responsible for **Data Definition** and **Data Access**.

**Protocols:**
- **Data Protocol:** Object schema, fields, validation, queries, filters
- **Driver Protocol:** Database adapters for Postgres, MongoDB, SQLite, etc.
- **Permission Protocol:** Object-level CRUD, field-level security, sharing rules
- **AI Protocol:** AI agents, RAG pipelines, NLQ, predictive models

**Role:** Defines *Structure* (Schema) and *Intent* (Query AST).

**Responsibility:** It knows *what* a "Customer" object looks like, but it doesn't know *who* is accessing it or *how* it is displayed.

**Key Component:** The **Compiler**. It takes an abstract query (`find customers where active = true`) and translates it into optimized SQL/NoSQL queries for the specific underlying database.

### 2. Presentation Layer (ObjectUI)
**"Server-Driven UI"**

The interface layer responsible for **Visual Representation** and **User Interaction**.

**Protocols:**
- **UI Protocol:** Apps, views, dashboards, reports, actions, themes

**Role:** Projects the Data Protocol into visual components.

**Responsibility:** It knows *how* to display a "Customer" form, but it doesn't know the business rules or who can access it.

**Key Component:** The **Renderer**. It takes UI metadata (JSON) and renders it as native components (React, Flutter, etc.).

### 3. Control Layer (ObjectOS)
**"The Business Kernel"**

The orchestration layer responsible for **Runtime** and **Governance**.

**Protocols:**
- **System Protocol:** Events, jobs, translations, audit logging
- **Auth Protocol:** Identity, roles, sessions, authentication
- **Kernel Protocol:** Plugin lifecycle, manifest, context
- **Hub Protocol:** Marketplace, licensing, tenancy
- **API Protocol:** REST contracts, discovery, realtime
- **Automation Protocol:** Workflows, flows, webhooks

**Role:** Orchestrates the entire system and enforces policies.

**Responsibility:** It knows *who* is accessing *what* and *when* actions should happen.

**Key Component:** The **Kernel**. It manages plugins, handles events, enforces security, and coordinates between layers.

## How They Work Together

```
┌─────────────────────────────────────────┐
│          Control Layer (ObjectOS)        │
│  ┌──────────┐  ┌────────┐  ┌──────────┐│
│  │ Kernel   │  │ Auth   │  │ System   ││
│  │ Protocol │  │Protocol│  │ Protocol ││
│  └──────────┘  └────────┘  └──────────┘│
└─────────────────────────────────────────┘
           ↕                    ↕
┌──────────────────┐    ┌──────────────────┐
│ Data Layer (QL)  │    │ UI Layer (UI)    │
│  ┌────────────┐  │    │  ┌────────────┐  │
│  │ Data       │  │    │  │ UI         │  │
│  │ Protocol   │  │    │  │ Protocol   │  │
│  └────────────┘  │    │  └────────────┘  │
│  ┌────────────┐  │    │                  │
│  │ Driver     │  │    │                  │
│  │ Protocol   │  │    │                  │
│  └────────────┘  │    │                  │
└──────────────────┘    └──────────────────┘
         ↕
   ┌──────────┐
   │ Database │
   └──────────┘
```

### Example: Creating a Record

1. **UI Layer:** User clicks "Save" on a Customer form
2. **Control Layer:** Kernel receives the request, validates authentication
3. **Data Layer:** ObjectQL compiler generates SQL INSERT statement
4. **Driver:** PostgreSQL driver executes the query
5. **Control Layer:** Event system triggers "after_create" workflow
6. **UI Layer:** Renderer updates the interface with the new record

## Protocol vs Implementation

**Critical Distinction:**

- **Protocol Layer:** Defined in `packages/spec` (This Repository)
  - Pure Zod schemas
  - TypeScript types
  - No runtime logic

- **Runtime Layer:** Implemented in separate packages
  - Node.js Kernel (`@objectstack/kernel`)
  - React Renderer (`@objectstack/react`)
  - PostgreSQL Driver (`@objectstack/driver-postgres`)

The protocol defines the "what" and "how." The runtime implements it.

## Design Benefits

### 1. Composability
Each protocol can be used independently or combined with others.

### 2. Replaceability
Don't like the React renderer? Build a Vue or Flutter one. The protocol stays the same.

### 3. Testability
Test against the protocol specification, not a specific implementation.

### 4. Future-Proof
New features are additive, not breaking. Implementations can evolve independently.

## Next Steps

- [Glossary](/docs/00-introduction/glossary) - Key terminology explained
- [Core Concepts](/docs/01-core-concepts) - Understand metadata-driven development
- [Protocols](/docs/02-protocols) - Dive into each protocol specification
