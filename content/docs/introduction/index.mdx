---
title: What is ObjectStack?
description: ObjectStack is What? A Full-Stack Metadata Protocol for Building Enterprise Applications
---

import { Database, Layout, Cog } from 'lucide-react';

**ObjectStack** is not just a framework; it is a **Protocol** for building enterprise software. It decouples the *Business Intent* (defined in JSON/YAML) from the *Technical Execution* (handled by the Kernel).

## The Problem

In traditional development, application logic is scattered:

1. **Database Schema** (`table.sql`)
2. **Backend Models** (`User.ts`)
3. **Frontend Validation** (`schema.zod.ts`)
4. **API Documentation** (`swagger.json`)

When requirements change, you update code in multiple places. This is **Implementation Coupling**.

## The Solution

We centralize the "Intent" into a single Protocol Definition (JSON/YAML). The implementation layers (React, Node.js, SQL) act merely as **Runtime Engines** that interpret this protocol.

<Cards>
  <Card
    icon={<Database />}
    title="Data Protocol"
    description="Define data structures, queries, and business logic. Database-agnostic abstraction layer."
  />
  <Card
    icon={<Layout />}
    title="UI Protocol"
    description="Server-driven UI definitions. Express interfaces as JSON, not code."
  />
  <Card
    icon={<Cog />}
    title="System Protocol"
    description="Runtime kernel, plugins, security, and integration. The platform foundation."
  />
</Cards>

## The "Stack" Analogy

Think of ObjectStack as:

- **Kubernetes** for business applications - Declarative configuration over imperative code
- **Terraform** for data modeling - Infrastructure as code, but for data
- **GraphQL + React Server Components** - Schema-driven data + UI rendering combined

## Key Features

### 1. Protocol-Driven Architecture

**The UI is a Projection. The API is a Consequence.**

- ObjectUI does not "build" a form; it *projects* the ObjectQL schema into a visual representation
- You do not write endpoints; ObjectOS *generates* the secure graph based on the access control protocol

### 2. Local-First by Default

**"The Cloud is a sync peer, not a master."**

- All interactions are optimistic and instant (0ms latency)
- Data lives on the user's device
- The server is just a hub for backup and collaboration

### 3. Database Agnostic

**ObjectQL treats the database as an Implementation Detail.**

- Start with SQLite for prototyping
- Migrate to PostgreSQL for production
- Archive to Snowflake for analytics
- **No code changes required**

## Real-World Benefits

| Traditional Approach | ObjectStack Approach |
| :--- | :--- |
| Write SQL migrations manually | Schema changes sync automatically |
| Build CRUD APIs by hand | REST/GraphQL generated from schema |
| Duplicate validation logic 3x | Define once, enforce everywhere |
| Lock into one database vendor | Swap databases without code changes |
| Offline = broken app | Offline-first with background sync |

## Who Should Use ObjectStack?

### Enterprise Developers
Building internal tools, CRMs, ERPs, or admin panels? ObjectStack eliminates 80% of the boilerplate.

### Platform Builders
Creating a SaaS product or multi-tenant application? ObjectStack provides enterprise-grade security and isolation.

### Integration Engineers
Connecting multiple systems? ObjectStack's protocol-driven approach makes it easy to map and transform data.

## Next Steps

- [Design Principles](/docs/introduction/design-principles) - Understand the philosophy
- [Architecture](/docs/introduction/architecture) - Deep dive into the system
- [Glossary](/docs/introduction/glossary) - Learn key terminology
- [Core Concepts](/docs/core-concepts) - Metadata-driven development explained
