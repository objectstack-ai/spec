---
title: Metadata-Driven Development
description: Understanding the core philosophy of defining business logic through metadata instead of code
---

import { Database, Code, Link, Laptop } from 'lucide-react';

# What is Metadata-Driven Development?

Metadata-driven development is a paradigm shift where **application logic is defined by declarative data (metadata), not imperative code.**

## The Problem with Code-First

In traditional development, the "Intent" (e.g., *"This field is a required email address"*) is scattered across multiple layers:

1. **Database:** SQL constraints (`NOT NULL`, `CHECK`)
2. **Backend:** ORM validation (TypeORM decorators, Prisma schemas)
3. **Frontend:** UI validation (React Hook Form + Zod)
4. **Documentation:** API specs (OpenAPI/Swagger)

When a business requirement changes, you must update code in **three or four places**. This is **Implementation Coupling**.

### Example: Adding a "Phone Number" Field

**Traditional Approach:**

```sql
-- 1. Database migration
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
```

```typescript
// 2. Backend model
class User {
  @Column()
  @IsPhoneNumber()
  phone: string;
}
```

```typescript
// 3. Frontend validation
const schema = z.object({
  phone: z.string().regex(/^\+?[1-9]\d{1,14}$/),
});
```

```yaml
# 4. API documentation
components:
  schemas:
    User:
      properties:
        phone:
          type: string
          pattern: '^\+?[1-9]\d{1,14}$'
```

**4 files to change. 4 places to keep in sync. 4 opportunities for bugs.**

## The Metadata-Driven Solution

ObjectStack centralizes the "Intent" into a **single Protocol Definition**. The implementation layers act as **Runtime Engines** that interpret this protocol.

### Example: The ObjectStack Way

```typescript
// ONE definition (in objectstack.config.ts)
import { ObjectSchema, Field } from '@objectstack/spec/data';

export const User = ObjectSchema.create({
  name: 'user',
  label: 'User',
  icon: 'user',
  
  fields: {
    phone: Field.phone({
      label: 'Phone Number',
      required: true,
    }),
  },
});
```

> **üìò Syntax Rules**: Always use `ObjectSchema.create()` with `Field.*` helpers for strict TypeScript validation and runtime checking. See [Object Definition Rules](#object-definition-rules) below.

From this single definition, ObjectStack automatically:

‚úÖ Generates database schema  
‚úÖ Creates validation rules  
‚úÖ Builds CRUD APIs  
‚úÖ Renders form fields  
‚úÖ Produces API documentation

## The Three Truths

In metadata-driven development, we embrace three core truths:

### 1. The UI is a Projection

**Traditional:** Build a form component manually  
**ObjectStack:** The form is a *projection* of the schema

The UI doesn't "build" a form; it **projects** the Object schema into visual components.

```typescript
// The schema IS the form
const TaskForm = <FormView object="task" />
// No manual JSX needed
```

### 2. The API is a Consequence

**Traditional:** Write REST endpoints by hand  
**ObjectStack:** APIs are *generated* from the schema

You don't write controllers or routes. ObjectOS *generates* the entire API graph based on your Object definitions and permission rules.

```bash
# Automatically available after defining the object:
GET    /api/v1/task
POST   /api/v1/task
GET    /api/v1/task/:id
PATCH  /api/v1/task/:id
DELETE /api/v1/task/:id
```

### 3. The Schema is the Application

**Traditional:** The "application" is code scattered across many files  
**ObjectStack:** The "application" is a collection of metadata files

Your entire business logic lives in:
- Object definitions (`.object.ts`)
- View configurations (`.view.ts`)
- Workflow rules (`.workflow.ts`)

The Kernel simply **interprets** these definitions.

## Benefits of Metadata-Driven

### 1. Single Source of Truth

Change the metadata once, everything updates automatically.

```typescript
// Change this:
phone: Field.phone({ required: true })

// To this:
phone: Field.phone({ required: false })

// ‚úÖ Database constraint updates
// ‚úÖ API validation updates
// ‚úÖ UI form updates
// ‚úÖ Documentation updates
```

### 2. Type Safety by Default

All metadata is defined with Zod schemas:

```typescript
// Source: Zod schema
const FieldSchema = z.object({
  name: z.string(),
  type: z.enum(['text', 'number', 'date']),
});

// Derived: TypeScript type
type Field = z.infer<typeof FieldSchema>;

// Derived: JSON Schema (for IDE autocomplete)
const jsonSchema = zodToJsonSchema(FieldSchema);
```

### 3. Technology Agnostic

Because logic is declarative, you can swap implementations:

```
Same Metadata Definition
          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   ‚îÇ
PostgreSQL      MongoDB
Node.js         Python
React           Flutter
```

### 4. Reduced Boilerplate

**Traditional:** ~300 lines of code for a simple CRUD feature  
**ObjectStack:** ~30 lines of metadata

```typescript
// All you need:
import { ObjectSchema, Field } from '@objectstack/spec/data';

export const Task = ObjectSchema.create({
  name: 'task',
  label: 'Task',
  icon: 'check-square',
  
  fields: {
    title: Field.text({ 
      label: 'Title',
      required: true,
    }),
    
    status: Field.select({
      label: 'Status',
      options: [
        { label: 'To Do', value: 'todo', default: true },
        { label: 'In Progress', value: 'in_progress' },
        { label: 'Done', value: 'done' },
      ],
    }),
    
    assignee: Field.lookup('user', {
      label: 'Assignee',
    }),
  },
});

// That's it. Full CRUD functionality is ready.
```

## Real-World Analogy

Think of metadata-driven development like **HTML vs Canvas**:

### HTML (Declarative)
```html
<h1>Hello World</h1>
```
You describe **what** you want. The browser handles **how** to render it.

### Canvas (Imperative)
```javascript
ctx.font = '32px Arial';
ctx.fillText('Hello World', 10, 50);
```
You specify **exactly how** to draw each pixel.

**ObjectStack is the "HTML" of enterprise applications.**

## When to Use Metadata-Driven

‚úÖ **Use metadata-driven when:**
- Building CRUD-heavy applications
- Need rapid prototyping and iteration
- Want database flexibility (may change backends)
- Building multi-tenant SaaS platforms
- Require strict type safety and validation

‚ùå **Don't use metadata-driven when:**
- Building highly custom, pixel-perfect UIs
- Need real-time 3D graphics or games
- The problem domain is too unique for abstraction
- Performance requires hand-optimized algorithms

## Summary

| Aspect | Traditional | Metadata-Driven |
| :--- | :--- | :--- |
| **Definition** | Code in multiple files | Single metadata definition |
| **Changes** | Update 3-4 places | Update once |
| **Type Safety** | Manual synchronization | Automatic from Zod |
| **Flexibility** | Locked to tech stack | Technology agnostic |
| **Boilerplate** | High (300+ lines) | Low (30 lines) |

## Object Definition Rules

When defining objects and metadata in ObjectStack, follow these strict rules and principles:

### 1. Always Use `ObjectSchema.create()` with `Field.*` Helpers

**‚úÖ Correct:**
```typescript
import { ObjectSchema, Field } from '@objectstack/spec/data';

export const Account = ObjectSchema.create({
  name: 'account',
  label: 'Account',
  fields: {
    name: Field.text({ required: true }),
    industry: Field.select({
      options: [
        { label: 'Technology', value: 'technology' },
        { label: 'Finance', value: 'finance' },
      ],
    }),
  },
});
```

**‚ùå Deprecated:**
```typescript
// Old pattern - no runtime validation
const Account: ServiceObject = {
  name: 'account',
  fields: {
    name: { type: 'text', required: true }
  }
};
```

**Why?**
- ‚úÖ **Type Safety**: Compile-time type checking via `z.input<typeof ObjectSchemaBase>`
- ‚úÖ **Runtime Validation**: Zod validates structure at runtime
- ‚úÖ **IDE Autocomplete**: Field helpers provide intelligent code completion
- ‚úÖ **Error Prevention**: Catches typos and invalid configurations immediately

### 2. Naming Conventions

Follow these strict naming conventions for consistency:

| Element | Convention | Examples |
|---------|-----------|----------|
| **Object Names** (machine names) | `snake_case` | `todo_task`, `project_milestone`, `user_profile` |
| **Field Names** (machine names) | `snake_case` | `first_name`, `annual_revenue`, `is_active` |
| **Constant Names** (exports) | `PascalCase` | `TodoTask`, `ProjectMilestone`, `UserProfile` |
| **Configuration Keys** (props) | `camelCase` | `maxLength`, `defaultValue`, `referenceFilters` |

**Example:**
```typescript
// ‚úÖ Correct naming
export const TodoTask = ObjectSchema.create({
  name: 'todo_task',                    // snake_case machine name
  label: 'Todo Task',
  
  fields: {
    due_date: Field.date({              // snake_case field name
      label: 'Due Date',
      defaultValue: null,               // camelCase config key
    }),
  },
});
```

### 3. Select Field Options Must Use Label/Value Objects

**‚úÖ Correct:**
```typescript
status: Field.select({
  label: 'Status',
  options: [
    { label: 'Open', value: 'open', default: true },
    { label: 'In Progress', value: 'in_progress' },
    { label: 'Closed', value: 'closed' },
  ],
}),
```

**‚ùå Incorrect:**
```typescript
status: Field.select({
  options: ['open', 'in_progress', 'closed'], // Wrong!
}),
```

**Why?** Option values are machine identifiers stored in the database and must be lowercase to avoid case-sensitivity issues in queries.

### 4. Lookup Fields Must Specify Target Object

**‚úÖ Correct:**
```typescript
owner: Field.lookup('user', {
  label: 'Owner',
  required: true,
}),
```

**‚ùå Incorrect:**
```typescript
owner: Field.lookup({
  object: 'user',  // Wrong property name
}),
```

### 5. Always Include Descriptive Labels

**‚úÖ Correct:**
```typescript
annual_revenue: Field.currency({
  label: 'Annual Revenue',
  scale: 2,
  min: 0,
}),
```

**‚ùå Avoid:**
```typescript
annual_revenue: Field.currency({
  // Missing label - field name will be used as fallback
}),
```

### 6. Use Enable Flags for Object Capabilities

```typescript
export const Account = ObjectSchema.create({
  name: 'account',
  label: 'Account',
  
  fields: { /* ... */ },
  
  enable: {
    trackHistory: true,     // Enable field history tracking
    searchable: true,       // Include in global search
    apiEnabled: true,       // Expose via REST/GraphQL
    files: true,            // Enable file attachments
    feeds: true,            // Enable activity feed
    activities: true,       // Enable tasks and events
    trash: true,            // Enable soft delete
    mru: true,              // Track Most Recently Used
  },
});
```

### Quick Reference

```typescript
import { ObjectSchema, Field } from '@objectstack/spec/data';

export const ExampleObject = ObjectSchema.create({
  name: 'example_object',           // Required: snake_case
  label: 'Example Object',          // Required: Human-readable
  pluralLabel: 'Example Objects',   // Optional
  icon: 'box',                      // Optional: Lucide icon name
  description: 'Description text',  // Optional
  
  fields: {
    // Text field
    text_field: Field.text({
      label: 'Text Field',
      required: true,
      maxLength: 255,
    }),
    
    // Number field
    number_field: Field.number({
      label: 'Number',
      min: 0,
      max: 100,
    }),
    
    // Currency field
    price: Field.currency({
      label: 'Price',
      scale: 2,
      min: 0,
    }),
    
    // Select field
    status: Field.select({
      label: 'Status',
      options: [
        { label: 'Active', value: 'active', default: true },
        { label: 'Inactive', value: 'inactive' },
      ],
    }),
    
    // Lookup field
    owner: Field.lookup('user', {
      label: 'Owner',
      required: true,
    }),
    
    // Boolean field
    is_active: Field.boolean({
      label: 'Active',
      defaultValue: true,
    }),
    
    // Date field
    due_date: Field.date({
      label: 'Due Date',
    }),
  },
  
  enable: {
    trackHistory: true,
    apiEnabled: true,
  },
});
```

## Next Steps

- [The Stack](/docs/core-concepts/the-stack) - How the three protocols work together
- [Object Model](/docs/core-concepts/object-model) - Deep dive into the universal object model
- [ObjectQL Protocol](/docs/protocols/objectql) - Learn the data protocol specification
