---
title: Design Principles
description: The unshakable core principles that govern the ObjectStack ecosystem - The Constitution of the Post-SaaS Era
---

import { Scale, Code2, Database, ScrollText } from 'lucide-react';

# Design Principles

ObjectStack exists to return enterprise application development to its essence: **Data**.

To maintain a healthy, decoupled, and future-proof ecosystem, we uphold the following core principles. These are not suggestions; they are the constraints that enable our freedom.

<Cards>
  <Card
    icon={<Scale />}
    title="I. Protocol Neutrality"
    description="The Protocol is law. The Implementation is merely an opinion."
  />
  <Card
    icon={<Code2 />}
    title="II. Mechanism over Policy"
    description="Provide the tools to build rules, do not hardcode the rules themselves."
  />
  <Card
    icon={<Database />}
    title="III. Single Source of Truth"
    description="There is no 'Code'. There is only Schema."
  />
  <Card
    icon={<ScrollText />}
    title="IV. Local-First by Default"
    description="The Cloud is a sync peer, not a master."
  />
</Cards>

---

## Principle I: Protocol Neutrality

**"The Protocol is neutral. The Engine is replaceable."**

ObjectQL must not contain any logic specific to a particular language (e.g., Node.js), database (e.g., PostgreSQL), or runtime (e.g., Browser).

### The Law

- **Spec before Engine:** Any feature must first be defined in the Specification layer (`packages/spec`) before a single line of code is written in the Engine layer. We reject the "implement first, standardize later" approach.
- **Zero Leakage:** Implementation details (like React Hooks usage, or SQL specific syntax) must never leak into the Protocol definition.

### The Benefit

This ensures that an ObjectStack application defined today can theoretically run on:

- A Node.js server with PostgreSQL (Today's Standard)
- A Python server with SQLite (AI/Data Science)
- A Rust WASM module in the browser (Local-First)

---

## Principle II: Mechanism over Policy

**"Give them the physics, not the simulation."**

ObjectStack provides the **Mechanisms** (The "How"):

- *"Here is how you define a validation rule."*
- *"Here is how you define a permission scope."*

ObjectStack never dictates the **Policy** (The "What"):

- *It never says "Passwords must be 8 characters".*
- *It never says "Users must belong to a Department".*

### Separation of Concerns

We cleanly separate the **Definition** from the **Execution**.

| Layer | Responsibility | Example |
| :--- | :--- | :--- |
| **Protocol (Mechanism)** | Defines the capabilities. | `allowRead: string` (A slot for a formula) |
| **App (Policy)** | Defines the business logic. | `allowRead: "$user.role == 'admin'"` |
| **Engine (Execution)** | Enforces the logic. | Compiles formula to SQL `WHERE` clause. |

---

## Principle III: The Single Source of Truth

**"There is no 'Code'. There is only Schema."**

In a traditional application, the "truth" is scattered:

1. Database Schema (`table.sql`)
2. Backend Models (`User.ts`)
3. Frontend Validation (`schema.zod.ts`)
4. API Documentation (`swagger.json`)

In ObjectStack, **The Object Protocol is the only truth.**

- The Database is a *derivative* of the Protocol.
- The UI is a *projection* of the Protocol.
- The API is a *consequence* of the Protocol.

If you change the Protocol, the entire system (DB, API, UI) must adapt automatically.

---

## Principle IV: Local-First by Default

**"The Cloud is a sync peer, not a master."**

We reject the notion that software must stop working when the internet connection drops.

- **Latency is the enemy:** All interactions should be optimistic and instant (0ms).
- **Ownership is the goal:** The user's data essentially lives on their device. The server is just a hub for backup and collaboration.

### The "Seven Hops" Problem

In a traditional Cloud app, a simple button click travels through:

```
Click → Wi-Fi → ISP → Cloud Load Balancer → Web Server → Database → Query Execution
```

...and then all the way back.

### The Local-First Solution

ObjectStack apps are designed to read and write to a **Local Database** (embedded within the client environment) first.

```
Click → Local DB → UI Update (0ms Latency)
```

The synchronization with the cloud happens in the background, asynchronously.

**Benefits:**

1. **Instant Response:** The UI reacts immediately (optimistic UI)
2. **Offline Capability:** Field workers, airplanes, or spotty connections are no longer blockers
3. **Data Sovereignty:** The data physically resides on the user's device

---

## Principle V: Strict Naming Conventions

**"Machine identifiers are lowercase. Always."**

In highly abstracted metadata-driven systems, distinguishing between "what humans read" (Labels) and "what machines read" (API Names) is fundamental.

### The Problem

Inconsistent naming creates:
- **Security vulnerabilities**: Case-sensitivity bugs in permission checks
- **Cross-platform issues**: Case-insensitive filesystems cause conflicts
- **Database problems**: Collation and case-sensitivity inconsistencies
- **URL encoding issues**: Mixed-case identifiers require encoding
- **Developer confusion**: Unclear which names are for display vs. storage

### The Solution

**All machine identifiers must be lowercase snake_case.**

This applies to everything that acts as a machine identifier:
- Object names (database tables)
- Field names (database columns)
- Role names
- Permission set names
- Action/trigger names
- App and page IDs
- Select option values
- Workflow/webhook names

### The Convention

| Type | Pattern | Example | Usage |
|------|---------|---------|-------|
| **Machine Identifier** | `snake_case` | `crm_account`, `first_name`, `sales_manager` | Stored values, API names |
| **Event Name** | `dot.notation` | `user.created`, `order.paid` | Event keys, message topics |
| **Label** | `Any Case` | `Sales Manager`, `In Progress` | Display text for users |
| **Schema Property** | `camelCase` | `maxLength`, `isRequired` | TypeScript properties |

### Example

```typescript
// Correct
{
  name: 'sales_manager',        // Machine identifier (snake_case)
  label: 'Sales Manager',       // Display label (readable)
  maxLength: 100                // Schema property (camelCase)
}

// Incorrect
{
  name: 'SalesManager',         // ❌ PascalCase
  name: 'sales-manager',        // ❌ kebab-case
  name: 'Sales Manager',        // ❌ Contains spaces
}
```

This convention:
- Aligns with industry standards (PostgreSQL, Salesforce, ServiceNow)
- Ensures cross-platform compatibility
- Prevents security vulnerabilities
- Provides URL-friendliness
- Maintains consistency across the entire ecosystem

**For implementation details, see:**
- [System Identifier Schema](/docs/references/shared/identifiers/SystemIdentifier)
- [Snake Case Identifier Schema](/docs/references/shared/identifiers/SnakeCaseIdentifier)  
- [Event Name Schema](/docs/references/shared/identifiers/EventName)

---

## Summary

These principles guide every design decision in ObjectStack:

| Principle | What it Means |
| :--- | :--- |
| **Protocol Neutrality** | The spec is separate from implementation. ObjectStack can run anywhere. |
| **Mechanism over Policy** | We provide the tools, you define the rules. |
| **Single Source of Truth** | The schema is the application. Everything else derives from it. |
| **Local-First** | Users own their data. The cloud is just for sync. |
| **Strict Naming Conventions** | Machine identifiers are lowercase snake_case. Labels are for humans. |

By adhering to these values, we build software that is **resilient to change**, **respectful of user time**, and **technically sovereign**.

## Next Steps

- [Architecture](/docs/introduction/architecture) - See how these principles shape the system
- [Glossary](/docs/introduction/glossary) - Understand key terms
- [Core Concepts](/docs/core-concepts) - Learn about metadata-driven development
