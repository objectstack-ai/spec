---
title: 编译器架构
description: ObjectQL 的高级架构。数据库编译器如何将声明性意图转换为物理执行。
---

import { Database, FileJson, ServerCog, ArrowRight } from 'lucide-react';

**ObjectQL** 决定数据层的行为。它被设计为一个**编译器**，将通用 JSON 中间表示（IR）转换为特定数据库的指令（SQL、NoSQL 等）。

## 架构管道

ObjectStack 数据引擎在四个不同的阶段运行。这种关注点分离使系统能够在保持原生性能的同时与数据库无关。

### 1. 定义阶段（Schema）
**输入：** YAML/JSON Schema 文件（`*.object.yml`）
**角色：** 定义数据的"形状"和"规则"。
**产物：**
*   **对象定义：** 表/集合。
*   **字段定义：** 列/属性。
*   **验证规则：** 完整性约束。

### 2. 组合阶段（AST）
**输入：** API 请求 / SDK 调用
**角色：** 将传入的意图解析为规范化的**抽象语法树（AST）**。
**关键操作：**
*   **验证：** 确保查询与 Schema 匹配。
*   **权限注入：** 基于 ACL 自动添加过滤器（例如，`AND owner = 'me'`）。
*   **规范化：** 将语法糖转换为严格的逻辑表达式。

### 3. 编译阶段（驱动程序）
**输入：** 规范化查询 AST
**角色：** 底层**驱动程序**（Postgres、SQLite、Mongo）接收 AST 并将其编译为数据库的原生语言。
**示例：**
*   *Postgres 驱动程序：* `SELECT * FROM accounts WHERE type = 'customer'`
*   *Mongo 驱动程序：* `db.accounts.find({ type: 'customer' })`

### 4. 执行阶段（结果）
**输入：** 原生游标
**角色：** 执行物理查询并将输出格式化回标准 JSON 协议。

---

## 协议三位一体

ObjectQL 由三个核心规范组成：

| 规范 | 范围 | 职责 |
| :--- | :--- | :--- |
| **[Schema 定义](./schema-definition)** | 静态 | 如何定义对象、字段和关系。 |
| **[AST 结构](./ast-structure)** | 运行时 | JSON 查询对象（"IR"）的结构。 |
| **[传输协议](./wire-protocol)** | 传输 | 客户端和服务器如何通过 HTTP 交换这些结构。 |

## 设计约束

为了维护"一次编写，随处运行"的承诺，ObjectQL 强制执行以下约束：

1.  **无泄漏抽象：** 你不能执行原始 SQL 字符串。所有访问都必须通过 AST。
2.  **幂等 Schema：** 应用两次 Schema 定义必须产生相同的数据库状态。
3.  **原子事务：** 所有变更操作（插入/更新/删除）默认必须是事务性的。
