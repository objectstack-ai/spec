---
title: Metadata-Driven Development
description: Understanding the core philosophy of defining business logic through metadata instead of code
---

import { Database, Code, Link, Laptop } from 'lucide-react';

# What is Metadata-Driven Development?

Metadata-driven development is a paradigm shift where **application logic is defined by declarative data (metadata), not imperative code.**

## The Problem with Code-First

In traditional development, the "Intent" (e.g., *"This field is a required email address"*) is scattered across multiple layers:

1. **Database:** SQL constraints (`NOT NULL`, `CHECK`)
2. **Backend:** ORM validation (TypeORM decorators, Prisma schemas)
3. **Frontend:** UI validation (React Hook Form + Zod)
4. **Documentation:** API specs (OpenAPI/Swagger)

When a business requirement changes, you must update code in **three or four places**. This is **Implementation Coupling**.

### Example: Adding a "Phone Number" Field

**Traditional Approach:**

```sql
-- 1. Database migration
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
```

```typescript
// 2. Backend model
class User {
  @Column()
  @IsPhoneNumber()
  phone: string;
}
```

```typescript
// 3. Frontend validation
const schema = z.object({
  phone: z.string().regex(/^\+?[1-9]\d{1,14}$/),
});
```

```yaml
# 4. API documentation
components:
  schemas:
    User:
      properties:
        phone:
          type: string
          pattern: '^\+?[1-9]\d{1,14}$'
```

**4 files to change. 4 places to keep in sync. 4 opportunities for bugs.**

## The Metadata-Driven Solution

ObjectStack centralizes the "Intent" into a **single Protocol Definition**. The implementation layers act as **Runtime Engines** that interpret this protocol.

### Example: The ObjectStack Way

```typescript
// ONE definition (in objectstack.config.ts)
export const User = Object({
  name: 'user',
  fields: {
    phone: Field.phone({
      label: 'Phone Number',
      required: true,
    }),
  },
});
```

From this single definition, ObjectStack automatically:

✅ Generates database schema  
✅ Creates validation rules  
✅ Builds CRUD APIs  
✅ Renders form fields  
✅ Produces API documentation

## The Three Truths

In metadata-driven development, we embrace three core truths:

### 1. The UI is a Projection

**Traditional:** Build a form component manually  
**ObjectStack:** The form is a *projection* of the schema

The UI doesn't "build" a form; it **projects** the Object schema into visual components.

```typescript
// The schema IS the form
const TaskForm = <FormView object="task" />
// No manual JSX needed
```

### 2. The API is a Consequence

**Traditional:** Write REST endpoints by hand  
**ObjectStack:** APIs are *generated* from the schema

You don't write controllers or routes. ObjectOS *generates* the entire API graph based on your Object definitions and permission rules.

```bash
# Automatically available after defining the object:
GET    /api/v1/task
POST   /api/v1/task
GET    /api/v1/task/:id
PATCH  /api/v1/task/:id
DELETE /api/v1/task/:id
```

### 3. The Schema is the Application

**Traditional:** The "application" is code scattered across many files  
**ObjectStack:** The "application" is a collection of metadata files

Your entire business logic lives in:
- Object definitions (`.object.ts`)
- View configurations (`.view.ts`)
- Workflow rules (`.workflow.ts`)

The Kernel simply **interprets** these definitions.

## Benefits of Metadata-Driven

### 1. Single Source of Truth

Change the metadata once, everything updates automatically.

```typescript
// Change this:
phone: Field.phone({ required: true })

// To this:
phone: Field.phone({ required: false })

// ✅ Database constraint updates
// ✅ API validation updates
// ✅ UI form updates
// ✅ Documentation updates
```

### 2. Type Safety by Default

All metadata is defined with Zod schemas:

```typescript
// Source: Zod schema
const FieldSchema = z.object({
  name: z.string(),
  type: z.enum(['text', 'number', 'date']),
});

// Derived: TypeScript type
type Field = z.infer<typeof FieldSchema>;

// Derived: JSON Schema (for IDE autocomplete)
const jsonSchema = zodToJsonSchema(FieldSchema);
```

### 3. Technology Agnostic

Because logic is declarative, you can swap implementations:

```
Same Metadata Definition
          ↓
┌─────────┴─────────┐
│                   │
PostgreSQL      MongoDB
Node.js         Python
React           Flutter
```

### 4. Reduced Boilerplate

**Traditional:** ~300 lines of code for a simple CRUD feature  
**ObjectStack:** ~30 lines of metadata

```typescript
// All you need:
export const Task = Object({
  name: 'task',
  fields: {
    title: Field.text({ required: true }),
    status: Field.select({
      options: ['todo', 'in_progress', 'done'],
    }),
    assignee: Field.lookup({ object: 'user' }),
  },
});

// That's it. Full CRUD functionality is ready.
```

## Real-World Analogy

Think of metadata-driven development like **HTML vs Canvas**:

### HTML (Declarative)
```html
<h1>Hello World</h1>
```
You describe **what** you want. The browser handles **how** to render it.

### Canvas (Imperative)
```javascript
ctx.font = '32px Arial';
ctx.fillText('Hello World', 10, 50);
```
You specify **exactly how** to draw each pixel.

**ObjectStack is the "HTML" of enterprise applications.**

## When to Use Metadata-Driven

✅ **Use metadata-driven when:**
- Building CRUD-heavy applications
- Need rapid prototyping and iteration
- Want database flexibility (may change backends)
- Building multi-tenant SaaS platforms
- Require strict type safety and validation

❌ **Don't use metadata-driven when:**
- Building highly custom, pixel-perfect UIs
- Need real-time 3D graphics or games
- The problem domain is too unique for abstraction
- Performance requires hand-optimized algorithms

## Summary

| Aspect | Traditional | Metadata-Driven |
| :--- | :--- | :--- |
| **Definition** | Code in multiple files | Single metadata definition |
| **Changes** | Update 3-4 places | Update once |
| **Type Safety** | Manual synchronization | Automatic from Zod |
| **Flexibility** | Locked to tech stack | Technology agnostic |
| **Boilerplate** | High (300+ lines) | Low (30 lines) |

## Next Steps

- [The Stack](/docs/01-core-concepts/the-stack) - How the three protocols work together
- [Object Model](/docs/01-core-concepts/object-model) - Deep dive into the universal object model
- [ObjectQL Protocol](/docs/02-protocols/01-objectql) - Learn the data protocol specification
