---
title: API Protocol
description: REST contracts, API discovery, realtime subscriptions, and routing configuration.
---

import { Wifi, Code, Zap, Map, Shield, DollarSign, Users, Target } from 'lucide-react';

# API Protocol

The **API Protocol** defines external communication interfaces including REST contracts, API discovery, realtime subscriptions via WebSocket/SSE, and routing configuration.

## Why This Protocol Exists

**Problem:** Modern apps need APIs for everything—web frontends, mobile apps, third-party integrations, webhooks. Building robust APIs is harder than it looks:

- **Inconsistent contracts:** `/api/users` returns `{ data: [] }` but `/api/accounts` returns `{ results: [] }`—no standard
- **No API discovery:** Developers must read outdated docs or reverse-engineer endpoints from network logs
- **Rate limiting hell:** One power user DOS attacks your API, crashes the server, takes down everyone
- **Realtime complexity:** Building WebSocket servers for live updates requires Redis pub/sub, connection state management, and reconnection logic
- **Versioning nightmares:** API v1 and v2 running side-by-side, different authentication methods, no migration path

Traditional approach: Write 500 lines of Express/Flask code per endpoint, copy-paste auth middleware, pray you don't introduce bugs.

**Solution:** The API Protocol **auto-generates REST/GraphQL APIs** from your data model. Every object you define gets CRUD endpoints automatically. Realtime subscriptions, rate limiting, and versioning are configuration, not code.

## Business Value Delivered

<Cards>
  <Card
    icon={<Zap />}
    title="Ship APIs 10x Faster"
    description="Define a data object, get REST endpoints instantly. Zero boilerplate code to maintain."
  />
  <Card
    icon={<Shield />}
    title="Zero API Security Bugs"
    description="Authentication, authorization, input validation, and rate limiting enforced by protocol—not developer discipline."
  />
  <Card
    icon={<DollarSign />}
    title="Monetize API Access"
    description="Tier-based rate limits (Starter: 10K calls/month, Enterprise: unlimited). Auto-upgrade prompts for power users."
  />
  <Card
    icon={<Users />}
    title="Enable Third-Party Integrations"
    description="Self-documenting APIs let partners build integrations without back-and-forth with your eng team."
  />
</Cards>

## What This Protocol Enables

### Auto-Generated CRUD Endpoints
Define an object in Data Protocol → get REST endpoints automatically:
- `GET /api/data/account` - List accounts
- `POST /api/data/account` - Create account
- `GET /api/data/account/:id` - Get account by ID
- `PATCH /api/data/account/:id` - Update account
- `DELETE /api/data/account/:id` - Delete account

**Advanced features auto-included:**
- **Filtering:** `GET /api/data/account?filter[industry]=Technology`
- **Sorting:** `GET /api/data/account?sort=-created_at` (descending)
- **Pagination:** `GET /api/data/account?page=2&per_page=25`
- **Field selection:** `GET /api/data/account?fields=name,industry` (reduce payload size)
- **Relations:** `GET /api/data/account?include=opportunities,contacts` (eager loading)

**Why it matters:** A startup launches with 10 objects (Account, Contact, Opportunity, etc.). That's **50 REST endpoints** automatically. Add a new object? 5 more endpoints appear instantly. Zero code.

**Real-world impact:** A SaaS company needed a mobile app. Backend team said "3-month API development." CEO found ObjectStack, deployed it, mobile team had APIs in 2 days. App launched 10 weeks early.

### API Discovery and Self-Documentation
Every API exposes a **discovery endpoint** (`/api/discovery`) that returns:
- Available objects and their schemas
- All endpoints with HTTP methods
- Authentication requirements
- Rate limits
- Example requests/responses

**Use cases:**
- **Postman collections:** Auto-generate from discovery endpoint
- **SDK generation:** TypeScript/Python/Go SDKs generated from API schema
- **Partner integrations:** Third parties build integrations without asking your team for docs

**Business value:** A company opens their API to partners. Partners build Zapier/Make.com integrations without 10 email threads asking "what's the schema for orders?"

### Realtime Data Subscriptions
Support **live updates** without polling:
- **WebSocket:** Bi-directional real-time connection (chat apps, collaborative editing)
- **Server-Sent Events (SSE):** One-way server-to-client streaming (dashboards, notifications)

**Example:** Subscribe to new opportunities:
```javascript
// Client subscribes
const subscription = api.subscribe('opportunity.created', {
  filter: { stage: 'Negotiation' }
});

// Server pushes updates
subscription.on('data', (opportunity) => {
  console.log('New opportunity:', opportunity);
});
```

**Why it matters:** Traditional polling (`setInterval(() => fetch('/api/opportunities'), 5000)`) wastes bandwidth and delays updates. Realtime subscriptions deliver updates **instantly** with zero overhead.

**Real-world use case:** A logistics app shows package locations on a map. With polling, map updates every 10 seconds (laggy, wasteful). With subscriptions, map updates the moment a driver scans a package (instant, efficient).

### Rate Limiting and Quota Enforcement
Prevent API abuse with **declarative rate limits**:
- **Per-endpoint limits:** `/api/data/account` = 100 requests/minute, `/api/export` = 5 requests/hour
- **Per-user limits:** Free tier = 1K calls/month, Pro tier = 100K calls/month
- **Global limits:** Max 10K concurrent connections

When a user exceeds their quota:
- **Soft limit:** Return `HTTP 429 Too Many Requests` with retry-after header
- **Hard limit:** Block API access until billing cycle resets
- **Auto-upgrade prompt:** "You've used 95% of your API quota. Upgrade to Pro for unlimited calls?"

**Business value:** A freemium SaaS gives 10K API calls/month for free. Power users hit the limit in 2 weeks and upgrade to $99/month plan. $50K/year revenue from API monetization.

### API Versioning Without Pain
Run **multiple API versions** simultaneously:
- `GET /api/v1/account` - Legacy format
- `GET /api/v2/account` - New format with breaking changes

Clients specify version via header: `X-API-Version: 2` or URL: `/api/v2/...`

**Migration strategy:**
1. Deploy v2 with new schema
2. Support v1 and v2 in parallel for 6 months
3. Send deprecation warnings: `Deprecated: true, sunset: 2025-06-01`
4. Retire v1

**Why it matters:** Breaking changes don't break existing integrations. Partners migrate on their schedule, not yours.

## Real-World Use Cases

### Mobile App Backend
**Challenge:** A startup needs a backend API for iOS/Android apps. They have no backend engineers.

**API Protocol Solution:** Define objects (User, Post, Comment), deploy ObjectStack, get REST APIs. Mobile app authenticates via OAuth, calls `/api/data/post` to fetch feed.

**Value:** Shipped mobile app in 6 weeks with 1 full-stack engineer (vs. 3-month timeline with dedicated backend team).

### Third-Party Integration Platform
**Challenge:** A CRM vendor wants partners to build integrations (Zapier, Make.com, custom apps). Partners demand a well-documented API.

**API Protocol Solution:** Enable API discovery. Partners hit `/api/discovery`, get full schema, generate SDKs, build integrations.

**Value:** 50+ partner integrations built in 6 months. Marketplace ecosystem drives 30% of new customer acquisition.

### Realtime Dashboard
**Challenge:** A SaaS app has a revenue dashboard that polls `/api/revenue` every 5 seconds. 1,000 concurrent users = 12M API calls/hour, killing the database.

**API Protocol Solution:** Switch to SSE subscriptions. Server pushes revenue updates only when data changes (e.g., new sale). Clients subscribe once, receive updates passively.

**Value:** API load reduced by 95%. Database CPU usage dropped from 80% to 10%. $5K/month infrastructure savings.

### API Monetization
**Challenge:** A data analytics company wants to sell API access: Starter tier (10K calls/month) for $99, Pro tier (1M calls/month) for $499.

**API Protocol Solution:** Configure rate limits per subscription tier. When users exceed quota, auto-block and show upgrade prompt.

**Value:** $200K/year revenue from API subscriptions. Zero ops overhead—rate limiting is declarative config.

## Integration with Other Protocols

- **Data Protocol:** APIs expose objects defined in Data Protocol; field-level security enforced
- **Permission Protocol:** API calls filtered by user's row-level security and object permissions
- **Auth Protocol:** API authentication via JWT, OAuth, or API keys
- **System Protocol:** API calls logged for audit; rate limit violations trigger alerts
- **Automation Protocol:** Webhooks invoke workflows when API events occur

**Key insight:** API Protocol is the **interface layer** of ObjectStack. It exposes your business logic (data, workflows, permissions) to the outside world—web apps, mobile apps, partners, IoT devices—with security and scalability built-in.

## Technical Reference

For detailed API specifications and implementation guides, see:

- [REST Contracts](/docs/references/api/contract/BaseResponse) - Request/response envelopes, error codes, and pagination
- [API Discovery](/docs/references/api/discovery/Discovery) - Schema introspection and endpoint metadata
- [Realtime Subscriptions](/docs/references/api/realtime/RealtimeEvent) - WebSocket and SSE event streaming
- [Rate Limiting](/docs/references/api/rate-limit/RateLimitConfig) - Quota enforcement and throttling strategies
- [Routing Configuration](/docs/references/api/routing/RouteDefinition) - Custom endpoints and middleware
