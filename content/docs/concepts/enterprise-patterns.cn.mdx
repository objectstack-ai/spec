---
title: 企业模式
description: 使用协议驱动方法处理复杂的 ERP/CRM 业务逻辑（状态机、计算、RBAC）。
---

import { Sliders, GitMerge, Calculator, BookOpen } from 'lucide-react';

关于"低代码"或"协议驱动"平台的一个常见误解是它们只适用于简单的 CRUD 应用程序。

虽然许多可视化构建器确实如此，但 **ObjectStack** 专门为企业资源计划（ERP）和客户关系管理（CRM）系统的复杂性而设计。我们不是通过隐藏复杂性来处理它，而是通过在协议中**显式建模**它来处理。

以下是我们如何将常见的企业模式映射到 ObjectStack 架构。

## 1. 工作流作为状态机（FSM）

在企业软件中，记录（例如，"采购订单"）很少只是静态数据。它是一个在生命周期中移动的活实体。

### 反模式
在控制器中编写分散的 `if/else` 逻辑：
```javascript
// 不要这样做
if (order.status === 'draft' && user.role === 'manager') {
  order.status = 'approved';
}
```

### ObjectStack 模式
我们将生命周期定义为自动化协议（工作流）中的**有限状态机（FSM）**。这使业务流程具有确定性和可视化。

```yaml
# workflows/purchase_order.yaml
name: purchase_approval
object: purchase_order
states:
  draft:
    initial: true
    on_exit: ['validate_budget']
    transitions:
      submit: pending_approval
  pending_approval:
    transitions:
      approve: approved
      reject: rejected
    guards:
      approve: "user.has_permission('approve_budget')"
  approved:
    final: true
```

## 2. 动态汇总（计算字段）

ERP 系统通常需要"主-明细"数学。*示例：订单的总额是其行项目的总和。*

### 反模式
在每个报表中手动编写 SQL `SUM()` 查询，或使用难以调试的数据库触发器。

### ObjectStack 模式
我们在数据协议（对象 schema）中定义**汇总字段**。数据层编译器处理底层复杂性（通过实时 `JOIN` 或后台聚合）。

```yaml
# objects/order.yml
fields:
  total_amount:
    type: summary
    summary_object: line_items
    summary_field: amount
    summary_type: sum
```

## 3. 多态关系

CRM 系统通常需要"多对任意"关系。*示例：任务可以与潜在客户、联系人或客户相关。*

### ObjectStack 模式
我们使用具有多个目标的 `reference` 类型。

```yaml
# objects/task.yml
fields:
  related_to:
    type: lookup
    reference_to: ['lead', 'contact', 'account', 'opportunity']
```

这指示数据层编译器生成必要的多态键（例如，`related_to_id` 和 `related_to_type` 列）。

## 总结

ObjectStack 通过**将模式提升为协议**来处理企业复杂性。

| 模式 | 传统代码 | ObjectStack 协议 |
| :--- | :--- | :--- |
| **逻辑** | 意大利面条式 `if/else` | 状态机（YAML） |
| **数学** | 手动循环/SQL | 虚拟/汇总字段 |
| **关系** | 自定义连接表 | 多态引用 |
