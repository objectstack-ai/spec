---
title: 宣言
description: 管理 ObjectStack 生态系统的不可动摇的核心原则。后 SaaS 时代的宪法。
---

import { ScrollText, Scale, Database, Code2 } from 'lucide-react';

ObjectStack 的存在是为了将企业应用程序开发回归其本质：**数据**。

为了维护一个健康、解耦和经得起未来考验的生态系统，我们承诺坚守以下不可动摇的核心原则。这些不是建议；它们是使我们获得自由的约束。

<Cards>
  <Card
    icon={<Scale />}
    title="I. 协议中立性"
    description="协议即法律。实现仅仅是一种意见。"
  />
  <Card
    icon={<Code2 />}
    title="II. 机制优于策略"
    description="提供构建规则的工具，而不是硬编码规则本身。"
  />
  <Card
    icon={<Database />}
    title="III. 数据主权"
    description="数据属于用户，而不是 SaaS 提供商。"
  />
</Cards>

---

## 原则 I：协议中立性

**"协议是中立的。引擎是可替换的。"**

ObjectQL 不得包含任何特定于特定语言（例如 Node.js）、数据库（例如 PostgreSQL）或运行时（例如浏览器）的逻辑。

### 法则
*   **先规范后引擎：** 在规范层（`packages/spec`）编写任何功能之前，必须首先在规范层定义该功能。我们拒绝"先实现，后标准化"的方法。
*   **零泄漏：** 实现细节（如 React Hooks 使用或 SQL 特定语法）绝不能泄漏到协议定义中。

### 好处
这确保了今天定义的 ObjectStack 应用程序理论上可以在以下环境中运行：
*   带 PostgreSQL 的 Node.js 服务器（今天的标准）
*   带 SQLite 的 Python 服务器（AI/数据科学）
*   浏览器中的 Rust WASM 模块（本地优先）

---

## 原则 II：机制优于策略

**"给他们物理学，而不是模拟。"**

ObjectStack 提供**机制**（"如何"）：
*   *"这是你如何定义验证规则。"*
*   *"这是你如何定义权限范围。"*

ObjectStack 从不规定**策略**（"什么"）：
*   *它从不说"密码必须是 8 个字符"。*
*   *它从不说"用户必须属于一个部门"。*

### 关注点分离
我们清晰地将**定义**与**执行**分离。

| 层 | 职责 | 示例 |
| :--- | :--- | :--- |
| **协议（机制）** | 定义能力。 | `allowRead: string`（公式的插槽） |
| **应用（策略）** | 定义业务逻辑。 | `allowRead: "$user.role == 'admin'"` |
| **引擎（执行）** | 执行逻辑。 | 将公式编译为 SQL `WHERE` 子句。 |

---

## 原则 III：单一数据源

**"没有'代码'。只有 Schema。"**

在传统应用程序中，"真相"是分散的：
1.  数据库 Schema（`table.sql`）
2.  后端模型（`User.ts`）
3.  前端验证（`schema.zod.ts`）
4.  API 文档（`swagger.json`）

在 ObjectStack 中，**对象协议是唯一的真相。**
*   数据库是协议的*衍生物*。
*   UI 是协议的*投影*。
*   API 是协议的*结果*。

如果你改变了协议，整个系统（DB、API、UI）必须自动适应。

---

## 原则 IV：默认本地优先

**"云是同步对等方，而不是主控方。"**

我们拒绝软件在互联网连接中断时必须停止工作的观念。
*   **延迟是敌人：** 所有交互都应该是乐观的和即时的（0ms）。
*   **所有权是目标：** 用户的数据实质上存储在他们的设备上。服务器只是备份和协作的中心。

---

> "我们塑造我们的工具，此后我们的工具塑造我们。" — 马歇尔·麦克卢汉
