---
title: Plugin Architecture
description: The Extension Model and Microkernel Philosophy of ObjectStack.
---

# Plugin Architecture

ObjectStack follows a strict **Microkernel Architecture**. The core platform provides only the minimal runtime environment (Kernel), while all business capabilities, including standard ones like CRM or Project Management, are delivered as **Packages** (Apps or Plugins).

## 1. Philosophy: "Kernel + Plugins"

*   **The Kernel**: Responsible for booting, identity, permission enforcement, and loading the manifest. It knows *nothing* about "Leads", "Tasks", or even "Kanban Boards" initially.
*   **The Plugins**: Teach the Kernel new tricks.
    *   **Apps**: Combinations of data and UI for end-users (e.g., "Sales App").
    *   **Plugins**: Extensions to the system capabilities (e.g., "BI Engine", "SAML Auth", "Stripe Payment").

This separation ensures the platform remains lightweight and un-opinionated, allowing it to evolve indefinitely.

## 2. Anatomy of a Plugin

A plugin is defined by its `Manifest` (objectstack.config.ts) and its runtime `Entry` (index.ts).

### The Manifest (`objectstack.config.ts`)

Critically, the manifest declares **Dependencies**, **Configuration Rules**, and **Contributions**.

```typescript
// objectstack.config.ts
import { ObjectStackManifest } from '@objectstack/spec';

const plugin: ObjectStackManifest = {
  id: 'com.vendor.bi',
  version: '1.0.0',
  type: 'plugin',
  
  // 1. Configuration Schema (Settings)
  configuration: {
    title: 'BI Engine Settings',
    properties: {
      'fullQueryMode': { 
        type: 'boolean', 
        default: false,
        description: 'Allow unrestricted SQL queries' 
      },
      'apiKey': {
        type: 'string',
        secret: true
      }
    }
  },

  // 2. Dependencies
  dependencies: {
    'com.objectstack.core': '^2.0.0'
  },

  // 3. Contributions (Declarative Capabilities)
  contributes: {
    // Define new Metadata Kinds (File Types)
    kinds: [
      { 
        id: 'bi.dataset', 
        globs: ['**/*.dataset.json'],
        description: 'BI Dataset Definition' 
      }
    ],
    // UI Contributions
    menus: {
      'global/toolbar': [
         { id: 'open_dashboard', label: 'Open BI Dashboard', command: 'bi.open' }
      ]
    },
    // Server Actions (Exposed to Flows/API)
    actions: [
      { 
        name: 'generate_forecast',
        label: 'Generate Sales Forecast',
        input: { startDate: 'date' }
      }
    ]
  },
  
  // 4. Runtime Entry
  extensions: {
    runtime: { entry: './src/index.ts' }
  }
}
```

## 3. Runtime Context

Plugins receive a rich strictly-typed `PluginContext` during their lifecycle. This context is the bridge to the host operating system.

```typescript
// src/index.ts
import { PluginDefinition, PluginContextData } from '@objectstack/spec';

const definition: PluginDefinition = {
  id: 'com.vendor.bi',
  
  onEnable: async (context: PluginContextData) => {
    // A. Access Type-Safe Context
    const { logger, ql, os, app, storage, i18n } = context;

    logger.info('Starting BI Engine...');

    // B. Use Scoped Storage (KV Store)
    const lastRun = await storage.get('last_run_timestamp');

    // C. Register Runtime Routes
    app.router.get('/bi/stats', async () => {
       return { active_reports: 10 };
    });

    // D. Interact with Core Data
    const data = await ql.object('account').find({ industry: 'Tech' });

    // E. Read Configuration
    const config = await os.getConfig('com.vendor.bi');
    if (config.fullQueryMode) { 
       logger.warn('Running in Full Query Mode');
    }
  }
}
```

## 4. Extension Capabilities

### A. New Metadata Kinds (CRDs)

This is the most powerful feature. A plugin can introduce entirely new concepts to the platform.

*   **Example**: A "BI Plugin" introduces `*.dataset.json` and `*.report.json`.
*   **Mechanism**: The Kernel uses the `contributes.kinds` registry to map file extensions to the plugin's parser.
*   **Result**: The IDE (cursor/vscode) and Runtime automatically recognize these files.

### B. Service Providers

Plugins can implement standard interfaces defined by the system.

*   **Auth Providers**: `plugin extends AuthProvider` (SAML, OAuth).
*   **Storage Drivers**: `plugin extends StorageDriver` (S3, MinIO).
*   **Notification Channels**: `plugin extends NotificationChannel` (Slack, SMS).

## 4. Plugin Lifecycle

The runtime manages the plugin states:

1.  **Resolve**: Read Manifest, validate dependencies.
2.  **Install (`onInstall`)**: Run migration scripts, setup initial data.
3.  **Boot (`onBoot`)**: Register generic services (before App load).
4.  **Enable (`onEnable`)**: Active and serving traffic.

```typescript
export class BiPlugin implements PluginLifecycle {
  async onEnable(context: PluginContext) {
    // Register the heavy engine only when enabled
    context.services.register('bi.engine', new BiAnalysisEngine());
  }
}
```
