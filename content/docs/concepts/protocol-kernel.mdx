---
title: Kernel Protocol
description: Plugin system, manifest definitions, lifecycle management, and runtime context for ObjectStack extensions.
---

import { Zap, Users, DollarSign, Target } from 'lucide-react';

# Kernel Protocol

The **Kernel Protocol** defines the plugin system and runtime management for ObjectStack. It enables a microkernel architecture where the core platform provides minimal runtime, while all capabilities are delivered as plugins.

## Why This Protocol Exists

**Problem:** Monolithic platforms (Salesforce, ServiceNow) force you to use their data model, their UI, their workflow engine—even if you only need 10% of features, you deploy 100% of the platform. This creates:

- **Bloat:** 500MB Docker images with dependencies you'll never use
- **Vendor lock-in:** Can't swap out their workflow engine for Temporal without forking the entire platform
- **Slow innovation:** Want AI-powered search? Wait for the vendor's roadmap (or never get it)
- **License costs:** Pay $150/user/month for "Enterprise Edition" just to get SSO

**Solution:** The Kernel Protocol implements a **microkernel architecture** like Linux or Kubernetes. The core runtime is &lt;10MB and does almost nothing—just loads plugins. Every feature (data access, UI, workflows, AI) is a plugin. Don't need dashboards? Don't load the dashboard plugin. Want better analytics? Replace the default plugin with your own.

## Business Value Delivered

<Cards>
  <Card
    icon={<Zap />}
    title="Ship Custom Features in Days"
    description="Build a plugin to integrate Stripe billing or Twilio SMS. Deploy without forking ObjectStack core."
  />
  <Card
    icon={<DollarSign />}
    title="Pay for What You Use"
    description="Disable unused plugins to reduce memory/CPU costs. 50% smaller deployments, 30% lower AWS bills."
  />
  <Card
    icon={<Users />}
    title="Ecosystem Marketplace"
    description="Download plugins from the marketplace: Shopify sync, DocuSign, Slack, Calendly—one-click install."
  />
  <Card
    icon={<Target />}
    title="Zero Core Upgrades"
    description="Core runtime rarely changes. Upgrade plugins independently without breaking dependencies."
  />
</Cards>

## What This Protocol Enables

### Plugin Isolation and Composability
Each plugin is a **self-contained module** with:
- **Manifest:** Declares what it provides (objects, views, actions) and what it needs (dependencies, configuration)
- **Lifecycle hooks:** `onInstall`, `onEnable`, `onDisable`, `onUninstall` for setup and teardown
- **Scoped context:** Plugins can't access each other's data or crash each other

**Why it matters:** A startup builds their CRM with "Sales" and "Support" plugins. Later, they add "Marketing Automation." The new plugin can **reference sales objects** without modifying sales plugin code. This is composability.

**Real-world impact:** An ISV (independent software vendor) sells vertical-specific CRMs (real estate, legal, healthcare). They maintain one core platform and **industry-specific plugin packages**. New vertical? Build a plugin, no core changes.

### Marketplace Economy
The Kernel Protocol enables a **plugin marketplace** like VS Code extensions or Salesforce AppExchange:
- **Plugin developers** build integrations (Stripe, QuickBooks, Zapier) and sell them
- **Platform users** install plugins with one click—no custom code needed
- **Revenue sharing** incentivizes third-party innovation

**Example:** Need Shopify integration? Search marketplace, find "Shopify Sync Pro" plugin ($29/month), install, configure API key, done. 15-minute setup vs. 2-week custom integration.

### Dependency Management
Plugins declare dependencies:
```
dependencies: {
  '@objectstack/core': '^2.0.0',
  'com.vendor.calendar': '>=1.5.0'
}
```
The runtime ensures **compatible versions** are loaded. Incompatible plugins fail fast at install time, not at runtime.

**Business value:** A company uses 10 third-party plugins. Core platform upgrades from v2.0 to v3.0. The runtime auto-checks which plugins are compatible. Incompatible plugins are disabled until vendors release updates. No surprise crashes.

### Resource Isolation
Plugins get **scoped storage and logging**:
- **Storage:** `context.storage.set('config', {...})` only affects this plugin's namespace
- **Logging:** `context.logger.info()` tags logs with plugin ID for debugging
- **Secrets:** Plugin configuration includes `secret: true` fields that are encrypted at rest

**Security impact:** A malicious plugin can't read another plugin's API keys or database credentials. Sandboxing prevents supply chain attacks.

## Real-World Use Cases

### SaaS Vertical Expansion
**Challenge:** A horizontal CRM vendor wants to sell to dentists, lawyers, and car dealerships. Each industry needs custom objects (Patient, Case, Vehicle) but shares core CRM.

**Kernel Protocol Solution:** Build industry-specific plugins:
- **Dental Plugin:** Patient object, appointment scheduling, insurance claims
- **Legal Plugin:** Case object, billable hours, court calendar integration
- **Auto Plugin:** Vehicle object, service history, DMV integration

Core CRM stays the same. Sell industry bundles.

**Value:** 3x revenue growth by entering new verticals. $0 additional platform maintenance cost.

### Custom Integration Without Vendor Approval
**Challenge:** A company uses ObjectStack but needs to integrate with an internal ERP system. Vendor doesn't support it.

**Kernel Protocol Solution:** Build a custom plugin:
```
onEnable(context) {
  // Sync data from ERP every hour
  context.scheduler.cron('0 * * * *', syncERPData);
  
  // Register custom API endpoint
  context.router.post('/api/erp/sync', handleSyncRequest);
}
```
Deploy the plugin. No pull request to ObjectStack core needed.

**Value:** Integration delivered in 1 week vs. 6-month vendor roadmap wait.

### Multi-Tenant Plugin Configuration
**Challenge:** A SaaS app has 1,000 tenants. Some use Stripe for billing, others use PayPal or manual invoicing.

**Kernel Protocol Solution:** Build a "Billing" plugin with **per-tenant configuration**:
- **Tenant A:** `billingProvider: 'stripe', stripeApiKey: 'sk_...'`
- **Tenant B:** `billingProvider: 'paypal', paypalClientId: 'AX...'`
- **Tenant C:** `billingProvider: 'manual'`

One plugin, three configurations.

**Value:** Support multiple payment providers without code forks. Win enterprise deals that require specific billing systems.

### Zero-Downtime Plugin Updates
**Challenge:** A critical bug is found in the "Email Notifications" plugin. Fix must deploy without taking the app offline.

**Kernel Protocol Solution:**
1. Upload new plugin version: `email-notifications@1.2.1`
2. Runtime performs **hot reload**: disables v1.2.0, enables v1.2.1
3. Active requests finish on old version, new requests use new version

**Value:** Fix deployed in 30 seconds, zero downtime. Traditional approach: deploy entire app, 5-minute outage.

## Integration with Other Protocols

- **Data Protocol:** Plugins contribute new objects via their manifest
- **UI Protocol:** Plugins register views, dashboards, and actions
- **Automation Protocol:** Plugins define workflows and flows
- **System Protocol:** Plugins schedule jobs and emit events
- **API Protocol:** Plugins register custom REST endpoints

**Key insight:** The Kernel Protocol is ObjectStack's **module system**. Just like Linux uses kernel modules (device drivers, file systems), ObjectStack uses plugins for everything. The core is stable; innovation happens at the plugin layer.

## Technical Reference

For implementation guides and API documentation, see:

- [Plugin Architecture](/docs/concepts/plugin-architecture) - Design principles and best practices
- [Manifest Reference](/docs/references/kernel/manifest/Manifest) - Package metadata, dependencies, and contribution declarations
- [Plugin Context API](/docs/references/kernel/plugin/PluginContext) - Runtime context with logger, storage, router, and scheduler
- [Lifecycle Hooks](/docs/references/kernel/plugin/Plugin) - onInstall, onEnable, onDisable, onUninstall event handlers
- [Logger Configuration](/docs/references/kernel/logger/LoggerConfig) - Log levels, formats, and output destinations
