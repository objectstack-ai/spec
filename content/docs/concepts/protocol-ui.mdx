---
title: UI Protocol
description: Server-Driven UI specification for building dynamic, metadata-driven user interfaces.
---

import { Zap, Users, DollarSign, Shield } from 'lucide-react';

# UI Protocol

The **UI Protocol** defines how user interfaces are described and rendered in ObjectStack. It follows the Server-Driven UI (SDUI) pattern where the backend dictates the layout, structure, and behavior, while the frontend acts as a renderer.

## Why This Protocol Exists

**Problem:** Traditional UI development hard-codes every form, table, and dashboard in React/Vue components. When business requirements change, developers must:

- Manually update dozens of components across web, mobile, and desktop apps
- Wait for app store approvals to fix a simple form layout bug
- Duplicate validation logic between frontend and backend
- Rebuild and redeploy entire applications just to add a new field to a form

This creates **months of lag** between business needs and software delivery. Even worse, business analysts can't configure UIs themselves—they must open tickets and wait for developer sprints.

**Solution:** The UI Protocol defines interfaces as **metadata**, not code. Describe your forms, dashboards, and reports in a declarative format. The frontend runtime reads these definitions at runtime and dynamically renders them. Change a form layout? Update metadata, deploy in seconds. Add a dashboard widget? No code changes, no app store submission.

## Business Value Delivered

<Cards>
  <Card
    icon={<Zap />}
    title="Ship UI Changes in Seconds"
    description="Update forms, dashboards, and reports without rebuilding apps. No app store approvals, no deployment pipelines."
  />
  <Card
    icon={<Users />}
    title="Empower Business Users"
    description="Analysts configure dashboards and reports themselves. IT becomes enablers, not bottlenecks."
  />
  <Card
    icon={<DollarSign />}
    title="50% Lower Frontend Costs"
    description="Write UI rendering logic once. Reuse across web, iOS, Android, desktop. One definition, infinite renderers."
  />
  <Card
    icon={<Shield />}
    title="Consistent UX Across Platforms"
    description="Same form layout on web, mobile, and desktop. Validation rules enforced everywhere automatically."
  />
</Cards>

## What This Protocol Enables

### One Definition, Every Platform
Define a form layout **once** in metadata. The UI Protocol's renderer architecture automatically adapts it:
- **Web:** React/Vue components with responsive CSS
- **Mobile:** Native iOS/Android widgets with platform-specific gestures
- **Desktop:** Electron/Tauri apps with keyboard shortcuts
- **Voice:** Alexa/Google Assistant skills with conversational flows

**Why it matters:** A startup ships a CRM with web and mobile apps in weeks, not quarters. Add a "notes" field to the Contact form? It appears everywhere instantly. No code reviews, no QA cycles, no 2-week iOS app approval wait.

### Business User Configurability
**Dashboards:** Sales managers build their own pipeline dashboards—no SQL, no BI tool expertise required. Drag widgets, set filters, done.

**Reports:** Finance creates matrix reports with cross-tabs and aggregations. IT doesn't need to write Crystal Reports or Power BI queries.

**Forms:** HR reconfigures the employee onboarding wizard when compliance rules change. Add a step, reorder fields, change validation—all in the UI.

**Real-world impact:** A SaaS company reduced IT backlog by 60% when they gave department heads dashboard configurability. The CEO created a real-time P&L dashboard at 11 PM without opening a ticket.

### Dynamic Runtime Updates
Traditional apps burn UI logic into JavaScript bundles. Every change requires:
1. Code change → 2. Build → 3. Test → 4. Deploy → 5. (iOS) Wait for Apple approval

**Server-Driven UI changes this:**
1. Update metadata → 2. Deploy (seconds)

**Use case:** Black Friday sale. Marketing needs to add a "promo code" field to checkout. With traditional UIs: 2-day deploy cycle, miss the sale. With UI Protocol: 30-second metadata update, deployed before lunch.

### Multi-Variant Experimentation
Run A/B tests on form layouts without developer involvement:
- **Variant A:** Single-page form with all fields visible
- **Variant B:** Wizard form with progress indicator

The protocol dynamically serves different `FormView` definitions to different user cohorts. Conversion metrics determine the winner.

**Business impact:** An e-commerce company increased checkout completion by 23% after testing 5 form layouts in a single week—previously impossible with hard-coded UIs.

## Real-World Use Cases

### SaaS White-Label Customization
**Challenge:** A CRM vendor sells to 500 customers. Each wants custom branding (logo, colors) and slightly different form layouts. Managing 500 React codebases is impossible.

**UI Protocol Solution:** Each tenant gets a custom **App** definition with their branding and **FormView** layouts. Same codebase serves all 500 customers with different UIs.

**Value:** Launch new customers in hours, not weeks. $2M/year saved on custom development work.

### Regulatory Compliance Agility
**Challenge:** A fintech company operates in 50 countries. Each country has different KYC (Know Your Customer) form requirements. EU requires GDPR consent checkboxes, India requires Aadhaar number, etc.

**UI Protocol Solution:** Define locale-specific **FormView** variants. The app dynamically shows the right form based on user location. Regulatory change? Update metadata, deploy immediately.

**Value:** Avoided $500K fine for non-compliance. New market entry time reduced from 3 months to 1 week.

### Offline-First Mobile Apps
**Challenge:** Field service technicians use a mobile app in areas with no connectivity. The app must work offline, sync when online, and match the web app's UI exactly.

**UI Protocol Solution:** Ship the same `ListView` and `FormView` definitions to mobile and web. Mobile app renders them natively (SwiftUI/Jetpack Compose). When forms change, push metadata updates via background sync.

**Value:** UI consistency eliminated $100K/year in support tickets caused by "why does mobile look different?" confusion.

### Rapid Prototyping for Startups
**Challenge:** A 2-person startup needs to validate 5 different product ideas. Building custom UIs for each idea would take months.

**UI Protocol Solution:** Define objects (Customer, Order, Product) and let ObjectStack auto-generate forms, tables, and dashboards. Iterate on product by tweaking metadata, not rewriting code.

**Value:** Shipped 3 MVPs in 6 weeks. Found product-market fit before running out of runway.

## Integration with Other Protocols

- **Data Protocol:** Forms automatically validate against field types and rules. No duplicate validation logic.
- **Permission Protocol:** Forms hide/disable fields based on field-level security. Action buttons disappear if user lacks permissions.
- **API Protocol:** Every UI component knows which REST endpoint to call. No manual wiring.
- **Automation Protocol:** Action buttons trigger workflows. "Approve" button runs approval flow automatically.

**Key insight:** The UI Protocol doesn't just define layouts—it's a **semantic layer** that connects user interactions to business logic. Click "Save" on a form? The protocol knows to validate, check permissions, call the API, trigger workflows, and refresh the dashboard—all without custom code.

## Technical Reference

For detailed schema definitions, component specifications, and implementation examples, see:

- [App Configuration](/docs/references/ui/app/App) - Navigation structure, branding, and app-level settings
- [ListView Reference](/docs/references/ui/view/ListView) - Grid, kanban, calendar, and gantt view configurations
- [FormView Reference](/docs/references/ui/view/FormView) - Form layouts with simple, tabbed, and wizard modes
- [Dashboard Reference](/docs/references/ui/dashboard/Dashboard) - Widget positioning and dashboard composition
- [Report Builder](/docs/references/ui/report/Report) - Tabular, summary, and matrix report types
- [Action Reference](/docs/references/ui/action/Action) - Button configuration and custom action definitions
- [Theme Customization](/docs/references/ui/theme/Theme) - Color schemes, typography, and styling options

