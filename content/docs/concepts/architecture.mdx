---
title: Architecture
description: Understanding the ObjectStack Protocol Architecture. How the 11 protocol namespaces collaborate to build the Enterprise Kernel.
---

import { Layers, Database, Layout, ShieldCheck, Lock, Cog, Brain, Cloud, Zap } from 'lucide-react';

ObjectStack is not a monolithic framework. It is a composable ecosystem designed around a **Protocol-Driven Architecture**. The system is organized into **11 protocol namespaces**, each responsible for a specific domain.

Each protocol is decoupled and communicates via standard JSON schemas defined with Zod. This allows you to swap out implementations (e.g., swapping the Postgres driver for MongoDB, or the React renderer for Flutter) without breaking the rest of the stack.

## Protocol Overview

ObjectStack is organized into 11 protocol namespaces:

<Cards>
  <Card
    icon={<Database />}
    title="Data Protocol"
    description="Object schema, fields, validation, and queries."
  />
  <Card
    icon={<Cog />}
    title="Driver Protocol"
    description="Database adapters (Postgres, MongoDB, SQLite, etc.)."
  />
  <Card
    icon={<ShieldCheck />}
    title="Permission Protocol"
    description="Object-level, field-level, sharing, and territory rules."
  />
  <Card
    icon={<Layout />}
    title="UI Protocol"
    description="Apps, views, dashboards, reports, and themes."
  />
  <Card
    icon={<Layers />}
    title="System Protocol"
    description="Events, jobs, translations, and audit logging."
  />
  <Card
    icon={<Lock />}
    title="Auth Protocol"
    description="Identity, roles, sessions, and authentication strategies."
  />
  <Card
    icon={<Cog />}
    title="Kernel Protocol"
    description="Plugin lifecycle, manifest, logging, and context."
  />
  <Card
    icon={<Cloud />}
    title="Hub Protocol"
    description="Marketplace, licensing, tenancy, and deployment."
  />
  <Card
    icon={<Brain />}
    title="AI Protocol"
    description="Agents, RAG, NLQ, predictive models, and orchestration."
  />
  <Card
    icon={<Zap />}
    title="API Protocol"
    description="REST contracts, discovery, realtime, and routing."
  />
  <Card
    icon={<Zap />}
    title="Automation Protocol"
    description="Workflows, flows, and webhooks."
  />
</Cards>

## The Three-Layer Architecture

While ObjectStack has 11 protocol namespaces, they are logically grouped into three architectural layers:

### 1. Data Layer (ObjectQL)
**"The Universal Data Protocol"**

The foundation layer responsible for **Data Definition** and **Data Access**.

**Protocols:**
* **Data Protocol:** Object schema, fields, validation, queries, filters
* **Driver Protocol:** Database adapters for Postgres, MongoDB, SQLite, etc.
* **Permission Protocol:** Object-level CRUD, field-level security, sharing rules
* **AI Protocol:** AI agents, RAG pipelines, NLQ, predictive models

**Role:** Defines *Structure* (Schema) and *Intent* (Query AST).

**Responsibility:** It knows *what* a "Customer" object looks like, but it doesn't know *who* is accessing it or *how* it is displayed.

**Key Component:** The **Compiler**. It takes an abstract query (`find customers where active = true`) and translates it into optimized SQL/NoSQL queries for the specific underlying database.

### 2. Control Layer (ObjectOS)
**"The Business Kernel"**

The orchestration layer responsible for **Runtime** and **Governance**.

**Protocols:**
* **System Protocol:** Events, jobs, translations, audit logging
* **Auth Protocol:** Identity, roles, sessions, authentication strategies
* **Kernel Protocol:** Plugin lifecycle, manifest, logging, context
* **Hub Protocol:** Marketplace, licensing, multi-tenancy, deployment
* **Automation Protocol:** Workflows, flows, webhooks

**Role:** Manages the *Lifecycle* of a request.

**Responsibility:**
* **Identity:** "Who is this user?" (Authentication)
* **Security:** "Can they see this field?" (RBAC/ACL)
* **Sync:** "How do we merge these offline changes?" (Conflict Resolution)
* **Process:** "What happens after this record is saved?" (Workflows/Triggers)

**Key Concept:** It acts as the gateway. No direct database access is allowed; everything must pass through the OS Kernel.

### 3. View Layer (ObjectUI)
**"The Projection Engine"**

The presentation layer responsible for **Interaction** and **Rendering**.

**Protocols:**
* **UI Protocol:** Apps, views, dashboards, reports, themes, actions
* **API Protocol:** REST contracts, discovery, realtime, routing

**Role:** Consumes the Protocol to render the Interface.

**Responsibility:** It does not contain hardcoded forms. Instead, it asks the Data Layer: *"What is the schema for a Customer?"* and dynamically renders a layout based on that metadata.

**Key Concept:** **Server-Driven UI (SDUI)**. The backend dictates the layout, validation rules, and available actions. The frontend is merely a highly capable renderer.

---

## The Request Lifecycle

To understand how these pieces fit together, let's trace a typical user interaction—for example, a Sales Rep updating a deal status while offline.

1.  **Interaction (UI Protocol):**
    *   User drags "Deal" to "Closed Won" column in Kanban.
    *   UI Optimistically updates the screen (0ms).
    *   UI dispatches an `update` action to the local Kernel.

2.  **Kernel Guard (Kernel Protocol):**
    *   Client Kernel checks via **Auth Protocol**: *Does user have permission to edit 'Status'?*
    *   Kernel executes **Data Protocol** validation: *Is 'Status' a valid option?*
    *   Transaction committed via **Driver Protocol** to SQLite (Local DB).

3.  **Synchronization (System Protocol):**
    *   Background process detects changes via **System Events**.
    *   Compresses change into an **Operation Payload** per **API Contract**.
    *   Sends payload to Server API via **API Protocol**.

4.  **Server Execution (Kernel Protocol):**
    *   Server Kernel authenticates via **Auth Protocol**.
    *   Server Kernel runs **Automation Protocol** triggers (e.g., Check credit limit).
    *   Server passes AST to Data Layer Compiler.

5.  **Persistence (Data + Driver Protocols):**
    *   **Driver Protocol** generates `UPDATE deals SET status = 'closed_won' ...` for PostgreSQL.
    *   Write is committed via **Driver Protocol**.
    *   **Automation Protocol** triggers fire (send email to manager via webhook).

## Protocol Dependencies

The protocols have clear dependencies and interact in a structured way:

```
Kernel Protocol (Runtime Core)
    ├── Auth Protocol (Identity & Sessions)
    ├── System Protocol (Events, Jobs, Audit)
    └── Hub Protocol (Tenancy, Licensing)
        
Data Protocol (Business Logic)
    ├── Driver Protocol (Storage Adapters)
    ├── Permission Protocol (Access Control)
    └── AI Protocol (Intelligence Layer)

UI Protocol (Presentation)
    └── API Protocol (Communication)

Automation Protocol (Business Processes)
    └── Depends on: Data, System, API
```

Each protocol is defined with Zod schemas in `@objectstack/spec` and can be independently validated, versioned, and evolved.
