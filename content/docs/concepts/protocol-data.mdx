---
title: Data Protocol
description: The foundation of ObjectStack - defining business data models, validation rules, and query language.
---

import { Database, CheckCircle, Target, Zap } from 'lucide-react';

# Data Protocol

The **Data Protocol** is the foundation of ObjectStack's data layer (ObjectQL). It defines the core business data model including object schemas, field types, validation rules, and the query language.

## Why This Protocol Exists

**Problem:** Traditional software development requires developers to manually write database schemas, validation logic, and query code for each database system. When business requirements change, developers must update schemas, migrate data, and modify countless SQL queries across the application. This creates:

- **Vendor Lock-in:** Switching from PostgreSQL to MongoDB requires rewriting the entire data layer
- **Inconsistent Validation:** Business rules scattered across frontend, backend, and database triggers
- **Slow Iteration:** Schema changes require coordinated deployments and complex migration scripts
- **Poor Developer Experience:** Writing boilerplate CRUD code instead of focusing on business logic

**Solution:** The Data Protocol provides a **single source of truth** for your business data model. Define your entities once in a declarative, database-agnostic format, and ObjectStack automatically:
- Generates database schemas for any supported backend (SQL, NoSQL, Graph, Time-series)
- Enforces validation rules consistently across all layers
- Migrates data when schemas evolve
- Optimizes queries for the underlying database

## Business Value Delivered

<Cards>
  <Card
    icon={<Zap />}
    title="10x Faster Development"
    description="No boilerplate CRUD code. Define objects declaratively and get REST APIs, UIs, and validation automatically."
  />
  <Card
    icon={<Database />}
    title="Database Portability"
    description="Start with SQLite, scale to PostgreSQL, add MongoDB for documents—no code changes required."
  />
  <Card
    icon={<Target />}
    title="Business Logic as Data"
    description="Business analysts can define fields and validation rules without developer intervention."
  />
  <Card
    icon={<CheckCircle />}
    title="Zero Data Inconsistency"
    description="Validation enforced at the protocol level prevents bad data at write time, not query time."
  />
</Cards>

## What This Protocol Enables

### Business Entity Definition
**Objects** are business entities like "Customer", "Order", "Invoice", "Project". Instead of writing CREATE TABLE statements, you define what the entity *means* to your business. ObjectStack handles the rest:
- Auto-generates database tables/collections
- Creates REST/GraphQL APIs
- Builds admin UIs with forms and lists
- Enables full-text search
- Tracks field history for compliance

**Real-world impact:** A 3-person startup can build a CRM with the same data model sophistication as Salesforce, without hiring database architects or DevOps engineers.

### Rich Field Types
ObjectStack provides **20+ specialized field types** that encode business semantics, not just data types:
- **Lookup Fields:** Relationships that maintain referential integrity (like foreign keys, but smarter)
- **Formula Fields:** Auto-calculated values (e.g., `total = quantity × price`) that update in real-time
- **Rollup Summary:** Aggregate child records (e.g., "Total opportunity value" on Account)
- **Currency Fields:** Store amounts with currency codes, automatic exchange rate conversion
- **Address/Location Fields:** Geocoding, distance calculations, territory assignment

**Why it matters:** These aren't just data types—they're business logic primitives. A "lookup" field knows it should display a dropdown in the UI, validate referential integrity, and support cascading deletes. You declare the *intent*, ObjectStack handles the *implementation*.

### Database-Agnostic Query Language
The protocol defines queries as **Abstract Syntax Trees (AST)**, not SQL strings. This means:
- Write one query, run on PostgreSQL, MongoDB, or Excel
- Automatically optimize for the target database (indexes, joins, etc.)
- Type-safe queries validated at compile time
- No SQL injection vulnerabilities

**Example use case:** A company starts with PostgreSQL, adds MongoDB for product catalogs, and Redis for caching. The same ObjectQL query (`find customers where industry = 'tech'`) works across all three—no code changes.

### Validation as First-Class Citizen
Business rules are defined alongside the data model, not scattered in application code:
- **Cross-field validation:** "If account type is Enterprise, revenue is required"
- **State machine validation:** "Can't close an opportunity without a quote"
- **Async validation:** "Check if email domain is blacklisted via external API"
- **Custom error messages:** Business-friendly error messages, not database errors

**Business impact:** Prevent $10M data quality issues caused by invalid records. Validation rules are auditable, testable, and versionable alongside your schema.

## Real-World Use Cases

### SaaS Multi-Tenancy
**Challenge:** Building a SaaS product where each customer needs isolated data, but you want to avoid managing hundreds of separate databases.

**Data Protocol Solution:** Define tenant-scoped objects with automatic row-level isolation. ObjectStack ensures Customer A can never query Customer B's data, even if they share the same PostgreSQL database.

**Value:** Launch a multi-tenant SaaS in weeks, not months. Add customers without infrastructure changes.

### Offline-First Mobile Apps
**Challenge:** Sales reps need to access CRM data on planes, in areas with poor connectivity, and must sync changes when back online.

**Data Protocol Solution:** The same object definitions work with SQLite (on-device) and PostgreSQL (cloud). Queries, validation, and business logic are identical. Conflict resolution is built into the protocol.

**Value:** Your field team stays productive even when offline. No "save failed" errors that lose $100K deals.

### Legacy System Migration
**Challenge:** You have data in Oracle, MongoDB, and Excel spreadsheets. You want to unify them without a 2-year ETL project.

**Data Protocol Solution:** Define a unified object model, then map each legacy system via a Driver. Data stays in place initially, queries federate across all three. Migrate incrementally as needed.

**Value:** Decouple business logic from legacy tech debt. Retire old systems on your schedule, not the vendor's EOL deadline.

## Integration with Other Protocols

The Data Protocol is the foundation that other protocols build upon:

- **Driver Protocol:** Compiles ObjectQL queries to PostgreSQL, MongoDB, Redis, etc.
- **Permission Protocol:** Enforces "who can see what" at the data layer, before queries execute
- **UI Protocol:** Auto-generates forms, tables, and dashboards from object schemas
- **API Protocol:** Exposes objects as REST/GraphQL endpoints with zero code
- **Automation Protocol:** Triggers workflows when data changes (e.g., "Send email when deal closes")

**Key insight:** Define your data model once. Everything else—UIs, APIs, permissions, workflows—is auto-generated and stays synchronized.

## Technical Reference

For detailed schema definitions, TypeScript interfaces, and implementation examples, see:

- [Object Schema Reference](/docs/references/data/object/Object) - Complete schema structure and field options
- [Query Language Reference](/docs/references/data/query/Query) - AST structure and filter operators
- [Validation Rules Reference](/docs/references/data/validation/ValidationRule) - Formula syntax and validation types
- [Field Types Guide](/docs/guides/field-types) - All 20+ field types with code examples
