---
title: Data Protocol
description: The foundation of ObjectStack - defining business data models, validation rules, and query language.
---

import { Database, FileJson, Filter, CheckCircle } from 'lucide-react';

# Data Protocol

The **Data Protocol** is the foundation of ObjectStack's data layer (ObjectQL). It defines the core business data model including object schemas, field types, validation rules, and the query language.

## Overview

The Data Protocol provides a declarative way to define your business entities and their relationships. Instead of writing SQL CREATE TABLE statements or MongoDB schema validators, you define everything in a type-safe, database-agnostic format using Zod schemas.

<Cards>
  <Card
    icon={<Database />}
    title="Object Schema"
    description="Define business entities with fields, capabilities, and metadata."
  />
  <Card
    icon={<FileJson />}
    title="Field Types"
    description="Rich field types: text, number, date, lookup, formula, and more."
  />
  <Card
    icon={<Filter />}
    title="Query AST"
    description="Database-agnostic query language with filters, sorting, and joins."
  />
  <Card
    icon={<CheckCircle />}
    title="Validation Rules"
    description="Business validation rules with custom error messages."
  />
</Cards>

## Key Components

### 1. Object Definition

An **Object** is the fundamental unit of data modeling in ObjectStack, equivalent to a "Table" in SQL or a "Collection" in NoSQL.

**Core Properties:**
- `name` - Machine name (snake_case)
- `label` - Human-readable name
- `fields` - Field definitions map
- `enable` - Capabilities (API, tracking, search, etc.)

**Example:**
```typescript
import { Data } from '@objectstack/spec';

const accountObject: Data.Object = {
  name: 'account',
  label: 'Account',
  labelPlural: 'Accounts',
  fields: {
    name: {
      name: 'name',
      type: 'text',
      label: 'Account Name',
      required: true
    },
    industry: {
      name: 'industry',
      type: 'select',
      label: 'Industry',
      options: [
        { value: 'technology', label: 'Technology' },
        { value: 'finance', label: 'Finance' }
      ]
    },
    annual_revenue: {
      name: 'annual_revenue',
      type: 'currency',
      label: 'Annual Revenue'
    }
  },
  enable: {
    api: true,
    trackHistory: true,
    search: true
  }
};
```

### 2. Field Types

The Data Protocol supports a rich set of field types:

**Basic Types:**
- `text` - Single-line text
- `textarea` - Multi-line text
- `number` - Numeric values
- `boolean` - True/false
- `date` - Date only
- `datetime` - Date and time

**Advanced Types:**
- `select` - Picklist with predefined options
- `lookup` - Reference to another object
- `master_detail` - Parent-child relationship
- `formula` - Computed values
- `rollup_summary` - Aggregate child records
- `currency` - Monetary values with currency code
- `percent` - Percentage values
- `email` - Email addresses with validation
- `phone` - Phone numbers
- `url` - Web URLs
- `address` - Structured address fields
- `location` - Geographic coordinates

### 3. Query Language

The Data Protocol includes a powerful query AST (Abstract Syntax Tree) that compiles to any database dialect:

**Query Structure:**
```typescript
import { Data } from '@objectstack/spec';

const query: Data.Query = {
  object: 'account',
  fields: ['name', 'industry', 'annual_revenue'],
  filters: {
    and: [
      { field: 'industry', operator: 'equals', value: 'technology' },
      { field: 'annual_revenue', operator: 'greaterThan', value: 1000000 }
    ]
  },
  sort: [
    { field: 'annual_revenue', direction: 'desc' }
  ],
  limit: 100
};
```

**Filter Operators:**
- Equality: `equals`, `notEquals`, `in`, `notIn`
- Comparison: `greaterThan`, `lessThan`, `greaterThanOrEqual`, `lessThanOrEqual`
- String: `contains`, `startsWith`, `endsWith`, `like`
- Special: `isNull`, `isNotNull`, `between`
- Set: `includes`, `excludes`

### 4. Validation Rules

Define business validation rules with custom error messages:

```typescript
import { Data } from '@objectstack/spec';

const validation: Data.ValidationRule = {
  name: 'revenue_required_for_enterprise',
  object: 'account',
  active: true,
  errorMessage: 'Enterprise accounts must have annual revenue specified',
  condition: {
    formula: 'AND(ISPICKVAL(type, "Enterprise"), ISBLANK(annual_revenue))'
  }
};
```

**Validation Types:**
- Format validation (email, phone, URL patterns)
- Cross-field validation
- Uniqueness constraints
- Custom formulas
- Async validation (API calls)
- State machine validation

## Use Cases

### Master-Detail Relationships

```typescript
const opportunityLineItem: Data.Object = {
  name: 'opportunity_line_item',
  label: 'Opportunity Line Item',
  fields: {
    opportunity: {
      name: 'opportunity',
      type: 'master_detail',
      label: 'Opportunity',
      reference: 'opportunity',
      required: true
    },
    product: {
      name: 'product',
      type: 'lookup',
      label: 'Product',
      reference: 'product'
    },
    quantity: {
      name: 'quantity',
      type: 'number',
      label: 'Quantity',
      defaultValue: 1
    },
    unit_price: {
      name: 'unit_price',
      type: 'currency',
      label: 'Unit Price'
    }
  }
};
```

### Formula Fields

```typescript
const totalAmount: Data.Field = {
  name: 'total_amount',
  type: 'formula',
  label: 'Total Amount',
  formula: 'quantity * unit_price',
  returnType: 'currency'
};
```

### Rollup Summary

```typescript
const totalOpportunityValue: Data.Field = {
  name: 'total_opportunity_value',
  type: 'rollup_summary',
  label: 'Total Opportunity Value',
  summaryObject: 'opportunity_line_item',
  summaryField: 'total_amount',
  summaryType: 'sum',
  filter: {
    field: 'opportunity',
    operator: 'equals',
    value: '{!id}'
  }
};
```

## Integration with Other Protocols

The Data Protocol integrates seamlessly with:

- **Driver Protocol** - Compiles queries to specific database dialects
- **Permission Protocol** - Enforces field-level and object-level security
- **Validation Protocol** - Validates data before persistence
- **UI Protocol** - Auto-generates forms and views from schema
- **API Protocol** - Exposes data via REST/GraphQL

## Best Practices

1. **Use snake_case for machine names** - All object and field names should use snake_case
2. **Define labels for all fields** - Make your UI user-friendly
3. **Enable appropriate capabilities** - Only enable features you need (API, tracking, etc.)
4. **Use lookup fields for relationships** - Don't store IDs as text fields
5. **Leverage formula fields** - Reduce data redundancy with computed values
6. **Add validation rules early** - Prevent bad data from entering the system

## Learn More

- [Field Types Guide](/docs/guides/field-types)
- [Query Language Reference](/docs/references/data/query/Query)
- [Validation Rules](/docs/references/data/validation/ValidationRule)
- [Object Schema Reference](/docs/references/data/object/Object)
