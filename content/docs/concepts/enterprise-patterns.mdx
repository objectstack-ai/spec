---
title: Enterprise Patterns
description: Handling complex ERP/CRM business logic (State Machines, Calculations, RBAC) using the Protocol-Driven approach.
---


A common misconception about "Low-Code" or "Protocol-Driven" platforms is that they are only suitable for simple CRUD applications.

While true for many visual builders, **ObjectStack** is architected specifically for the complexity of Enterprise Resource Planning (ERP) and Customer Relationship Management (CRM) systems. We handle complexity not by hiding it, but by **modeling it** explicitly in the protocol.

Here is how we map common Enterprise Patterns to the ObjectStack architecture.

## 1. Workflows as State Machines (FSM)

In enterprise software, a record (e.g., a "Purchase Order") is rarely just static data. It is a living entity that moves through a lifecycle.

**The Anti-Pattern:**
Writing scattered `if/else` logic in controllers:
```javascript
// Don't do this
if (order.status === 'draft' && user.role === 'manager') {
  order.status = 'approved';
}

```

**The ObjectStack Pattern:**
We define the lifecycle as a **Finite State Machine (FSM)** in the ObjectOS Protocol. This makes the business process deterministic and visualizeable.

```yaml
# workflows/purchase_order.yaml
name: purchase_approval
object: purchase_order
states:
  draft:
    initial: true
    on_exit: ['validate_budget']
    transitions:
      submit: pending_approval
  pending_approval:
    transitions:
      approve: approved
      reject: rejected
    guards:
      approve: "user.has_permission('approve_budget')"
  approved:
    final: true

```

* **Deterministic:** An order *cannot* jump from `draft` to `shipped` unless the protocol allows it.
* **Audit:** The engine automatically logs every transition (Who moved it? When? Why?).

## 2. High-Precision Calculations (Virtual Columns)

ERPs are essentially databases mixed with complex spreadsheets. You need to calculate tax, aggregate line items, and compute marginsâ€”often across millions of rows.

**The Anti-Pattern:**
Fetching all data into Node.js memory to loop and calculate. This kills performance.

**The ObjectStack Pattern:**
We use **ObjectQL Virtual Columns** to compile logic down to the database layer.

```yaml
# objects/invoice.object.yaml
name: invoice
fields:
  lines:
    type: master_detail
    reference_to: invoice_line
  
  # A summary field that compiles to a SQL subquery or aggregation
  total_amount:
    type: summary
    reference_to: lines
    summary_type: sum
    summary_field: amount
  
  # A formula field that compiles to a SQL expression
  margin_percent:
    type: formula
    formula: "(${total_amount} - ${cost}) / ${total_amount}"
    precision: 18
    scale: 2

```

* **Performance:** The ObjectQL Compiler translates `total_amount` into a highly optimized SQL `SUM()` or a materialized view.
* **Consistency:** The calculation is defined once in the Schema, ensuring the API, the UI, and the Reports all show the exact same number.

## 3. Granular Governance (Field-Level Security)

In an HR system, everyone can see an "Employee" record, but only HR Managers can see the "Salary" field.

**The Anti-Pattern:**
Manually stripping fields in API controllers: `delete user.salary`. This is error-prone; developers often forget one endpoint (e.g., the search API).

**The ObjectStack Pattern:**
Security is injected into the **Compilation Phase**.

```yaml
# permissions/hr_manager.permission.yaml
role: hr_manager
object: employee
allow_read: true
allow_edit: true
field_permissions:
  salary: 
    read: true
    edit: true

# permissions/employee.permission.yaml
role: employee
object: employee
allow_read: true
field_permissions:
  salary:
    read: false # The compiler physically removes this column from the SELECT statement

```

* **Safety:** If a user without permission tries to query `salary`, the ObjectQL engine throws a compilation error or returns `null` (depending on config). It never touches the database.

## 4. Master-Detail Interfaces (Compound UI)

Enterprise users require high-density interfaces. They need to edit an Order (Header) and its Items (Lines) on a single screen without page refreshes.

**The ObjectStack Pattern:**
ObjectUI supports **Compound Layouts** defined via JSON.

```json
{
  "type": "layout.master_detail",
  "props": {
    "master_object": "order",
    "detail_object": "order_line",
    "link_field": "order_id"
  },
  "children": [
    {
      "region": "header",
      "type": "form",
      "fields": ["customer", "date", "status"]
    },
    {
      "region": "body",
      "type": "grid.editable", // An Excel-like editable table
      "fields": ["product", "quantity", "price", "subtotal"]
    }
  ]
}

```

* **Transaction Awareness:** The ObjectUI engine knows these two datasets are linked. When the user clicks "Save", it constructs a **Transactional Mutation** to save both the Order and Lines atomically.

## 5. Audit Trails & Compliance

For Finance and Healthcare (HIPAA/SOX), "Who changed what" is a legal requirement.

**The ObjectStack Pattern:**
Because all mutations go through the ObjectQL Protocol, auditing is enabled by a single flag.

* **Protocol:** The engine captures the `before` and `after` state of every field.
* **Storage:** Changes are written to a localized `audit_log` table (or an immutable ledger).
* **Visualization:** ObjectUI provides a built-in "History" component that renders this log instantly.

## Summary

ObjectStack handles enterprise complexity by **elevating patterns into protocols**.

| Complexity | Traditional Code | ObjectStack Protocol |
| --- | --- | --- |
| **Process** | `if/else` spaghetti | **Finite State Machines (YAML)** |
| **Math** | Looping in memory | **Virtual Columns (SQL Compilation)** |
| **Secrecy** | Manual API filtering | **Engine-Level RBAC** |
| **UX** | Hardcoded React forms | **Master-Detail Layouts (JSON)** |
| **History** | Custom logging logic | **Native Audit Trail** |
