---
title: Driver Protocol
description: Database adapters connecting ObjectStack to PostgreSQL, MongoDB, SQLite, and other storage engines.
---

import { HardDrive, Plug, Zap, Code, Target, Shield } from 'lucide-react';

# Driver Protocol

The **Driver Protocol** defines the interface for database adapters that connect ObjectStack's Data Layer to various storage engines. Drivers translate the abstract query AST into database-specific queries (SQL, NoSQL, etc.).

## Why This Protocol Exists

**Problem:** Traditional applications hard-code database-specific SQL or NoSQL queries throughout the codebase. This creates devastating vendor lock-in:

- **Migration nightmares:** Moving from MySQL to PostgreSQL requires rewriting thousands of queries
- **Multi-database impossibility:** Can't use PostgreSQL for transactions AND MongoDB for catalogs in the same app
- **Performance blind spots:** Developers write queries without understanding database-specific optimizations
- **Innovation tax:** Can't adopt new databases (DuckDB, ClickHouse, Turso) without massive rewrites

**Solution:** The Driver Protocol decouples business logic from database implementation. Your application writes **one** query in ObjectQL AST format. The Driver compiles it to optimized SQL, MongoDB aggregation pipeline, or Redis commands—depending on which database you choose at runtime.

## Business Value Delivered

<Cards>
  <Card
    icon={<Plug />}
    title="Zero Vendor Lock-in"
    description="Start with SQLite in dev, deploy PostgreSQL in prod, migrate to PlanetScale later—without code changes."
  />
  <Card
    icon={<Target />}
    title="Polyglot Persistence"
    description="Use the right database for each workload: Postgres for transactions, MongoDB for documents, Redis for caching."
  />
  <Card
    icon={<Zap />}
    title="Automatic Optimization"
    description="Drivers generate database-specific query plans. Get MongoDB's $lookup or Postgres's LATERAL joins without knowing either."
  />
  <Card
    icon={<Shield />}
    title="Built-in Security"
    description="All drivers use parameterized queries. SQL injection is structurally impossible."
  />
</Cards>

## What This Protocol Enables

### Unified Interface, Diverse Implementations
All drivers implement the same contract: `create()`, `find()`, `update()`, `delete()`. Whether you're talking to PostgreSQL or MongoDB, the interface is identical. This enables:

- **Development freedom:** Build with SQLite locally, deploy to PostgreSQL/MySQL in production
- **Vendor negotiation leverage:** "We can migrate to Aurora in 2 weeks" is a powerful negotiating position
- **Technology adoption:** Evaluate DuckDB for analytics or Turso for edge deployments—just swap the driver
- **Team productivity:** Developers learn one data access API, not five different database clients

### Query Compilation, Not Translation
Drivers don't just "convert" queries—they **compile** them:
- **Postgres Driver:** Generates window functions, CTEs, and JSONB operators when beneficial
- **MongoDB Driver:** Uses aggregation pipelines with `$lookup` for joins, `$match` for filters
- **Redis Driver:** Compiles to Redis Search queries for text search, sorted sets for ordering
- **SQLite Driver:** Optimizes for single-threaded I/O, uses WITHOUT ROWID tables when appropriate

**Example:** The query `find customers where city = 'SF' AND revenue > 1M` becomes:
- **PostgreSQL:** `SELECT * FROM customers WHERE city = 'SF' AND revenue > 1000000 USING INDEX idx_city_revenue`
- **MongoDB:** `db.customers.find({ city: 'SF', revenue: { $gt: 1000000 } }).hint('city_revenue_idx')`
- **Redis:** `FT.SEARCH customers "@city:SF @revenue:[1000000 +inf]"`

All from the same ObjectQL AST.

### Driver Capabilities Declaration
Drivers declare what they support (transactions, joins, full-text search, etc.). The ObjectStack runtime:
- **Validates queries at compile time:** If you use window functions but the driver doesn't support them, you get an error before deployment
- **Graceful degradation:** Falls back to in-memory processing for unsupported features (e.g., client-side joins)
- **Capability-aware UI:** Admin UIs only show import/export options if the driver supports bulk operations

## Real-World Use Cases

### Startup to Enterprise Migration
**Challenge:** A startup launches with Heroku Postgres (free tier). As they grow, they need to migrate to RDS, then eventually to Aurora with read replicas.

**Driver Protocol Solution:** Change one line in config: `driver: 'postgres'` → `driver: 'aurora'`. The application code doesn't change. Run the migration during a maintenance window.

**Value:** Database migration goes from "6-month project with rewrite risk" to "2-hour deployment". Your team stays focused on product features, not infrastructure firefighting.

### Polyglot Persistence for Performance
**Challenge:** You have transactional data (orders, payments) in PostgreSQL, product catalogs in MongoDB (flexible schemas), and session data in Redis (fast TTL expiry).

**Driver Protocol Solution:** Define three datasources, each with a different driver. ObjectStack routes queries to the appropriate database based on object configuration. Joins across databases work transparently (federation).

**Value:** Use the best tool for each job without sacrificing application simplicity. 10x performance improvement on reads, 50% cost savings on infrastructure.

### Edge Computing with Offline Support
**Challenge:** Building a point-of-sale (POS) system for retail stores. Each store needs local data when the internet goes down, but must sync to a central cloud database when online.

**Driver Protocol Solution:** 
- **In-store:** SQLite driver with local file storage
- **Cloud:** PostgreSQL driver with central database
- **Sync logic:** ObjectStack's built-in replication handles conflict resolution

**Value:** Stores process $50K/day in sales even during internet outages. No lost transactions, no manual reconciliation.

### Legacy System Integration Without Migration
**Challenge:** You have customer data in Salesforce, inventory in SAP, and orders in an Oracle database from 2005. You want a unified view without a costly ETL project.

**Driver Protocol Solution:** Build drivers for each system (Salesforce REST API, SAP RFC, Oracle JDBC). ObjectStack queries federate across all three. Data stays in place—no migration needed.

**Value:** Deliver a unified dashboard in weeks, not quarters. Retire legacy systems incrementally as business priorities dictate.
    // 2. Execute query
    const results = await this.executeQuery(nativeQuery);
    
    // 3. Transform results to standard format
    return this.transformResults(results);
## Supported Databases

ObjectStack provides official drivers for:

**SQL:** PostgreSQL, MySQL, SQLite, PlanetScale, Neon, Supabase  
**NoSQL:** MongoDB, Redis  
**Cloud:** Aurora, Cloud SQL, DocumentDB  
**Special:** In-memory (testing), Excel files, Airtable, Google Sheets

**Extensibility:** Create custom drivers for proprietary databases, SaaS APIs, or data warehouses by implementing the `DriverInterface`.

## Integration with Other Protocols

- **Data Protocol:** Compiles ObjectQL queries to database-specific queries
- **Permission Protocol:** Injects row-level security filters before query execution
- **System Protocol:** Manages connection pools, monitors query performance
- **API Protocol:** Exposes driver capabilities via API metadata endpoints

## Technical Reference

For detailed implementation guides and API documentation, see:

- [Driver Interface Reference](/docs/references/driver/driver/DriverInterface) - Complete interface specification
- [Custom Driver Guide](/docs/guides/custom-driver) - Build your own driver
- [Datasource Configuration](/docs/references/driver/datasource/Datasource) - Connection and pooling options
- [Technology Compatibility Kit (TCK)](/docs/guides/driver-tck) - Testing framework for drivers
