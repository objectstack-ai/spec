---
title: The AI Codex
description: How to collaborate with Artificial Intelligence to build ObjectStack applications.
---

import { Bot, Terminal, FileJson, Sparkles } from 'lucide-react';

ObjectStack is designed to be **AI-Native**.

Because our fundamental unit of construction is the **Protocol (JSON/YAML Schema)** rather than imperative code, Large Language Models (LLMs) are exceptionally good at understanding and generating ObjectStack applications.

This guide provides the "System Prompt" mental model for developers working with Copilot, ChatGPT, or Claude to build ObjectStack apps.

## Why ObjectStack is Friendly to AI

| Feature | Code-First Support | ObjectStack Support |
| :--- | :--- | :--- |
| **Context Window** | Low. Requires reading thousands of lines of TS/SQL. | High. Schema is dense and declarative. |
| **Hallucination** | High. AI invents APIs that don't exist. | Low. Schema validation (Zod) rejects invalid output. |
| **Refactoring** | Hard. Requires rewriting detailed logic. | Easy. Just change a JSON property key. |

## The "Chief Protocol Architect" Persona

When prompting an AI to help you build, assign it the role of **Chief Protocol Architect**.

### The System Prompt

Copy this into your custom instructions:

```markdown
You are an expert ObjectStack Architect.
Your goal is to design declarative protocols, NOT imperative code.

1.  **Schema First:** Always start by defining the ObjectQL Schema (YAML/JSON).
2.  **Files**: When asked for a feature, output the relevant `.object.yml` or `.view.yml` files.
3.  **No SQL/React:** Do not write SQL queries or React components unless explicitly asked for a Driver or Renderer implementation.
4.  **Style:** Use `snake_case` for machine names and `camelCase` for configuration keys.
```

## Common Tasks

### 1. Generating Schema from Requirements

**User:** "I need a CRM system to track leads and opportunities."

**AI Response:**
```yaml
# objects/lead.yml
name: lead
fields:
  status:
    type: select
    options: ['new', 'contacted', 'qualified']
  annual_revenue:
    type: currency
    scale: 2

# objects/opportunity.yml
name: opportunity
fields:
  lead_id:
    type: lookup
    reference_to: lead
```

### 2. Generating UI Layouts

**User:** "Create a dashboard for the Sales Manager."

**AI Response:**
```yaml
# dashboards/sales_overview.yml
layout: grid
widgets:
  - type: chart
    title: "Revenue by Month"
    query: "select sum(amount), month(close_date) from opportunity group by month"
  - type: list
    object: opportunity
    filter: [["stage", "=", "closed_won"]]
```
- **RBAC**: Role-Based Access Control
- **FLS**: Field-Level Security

## AI-Assisted Schema Design

### Prompt Template

```
I need to create a Schema for [business scenario] in ObjectStack.

Business requirements:
- [Requirement 1]
- [Requirement 2]
- [Requirement 3]

Please generate a JSON Schema compliant with ObjectStack specifications, including:
1. All necessary field definitions
2. Field types (text, number, date, reference, etc.)
3. Field constraints (required, unique, etc.)
4. Relationship definitions between objects
```

### Example Conversation

**User**:
```
I need to create a Schema for an e-commerce order management system in ObjectStack.

Business requirements:
- Manage customer information (name, phone, email)
- Manage product information (name, price, stock)
- Manage orders (order number, customer, product list, total amount, status)
- Order statuses include: pending, paid, shipped, completed, cancelled

Please generate a JSON Schema compliant with ObjectStack specifications.
```

**AI Response**:
```json
{
  "objects": {
    "customers": {
      "label": "Customer",
      "fields": {
        "name": { "type": "text", "label": "Name", "required": true },
        "phone": { "type": "text", "label": "Phone" },
        "email": { "type": "email", "label": "Email", "unique": true }
      }
    },
    "products": {
      "label": "Product",
      "fields": {
        "name": { "type": "text", "label": "Product Name", "required": true },
        "price": { "type": "number", "label": "Price", "required": true },
        "stock": { "type": "number", "label": "Stock", "default": 0 }
      }
    },
    "orders": {
      "label": "Order",
      "fields": {
        "order_no": { "type": "text", "label": "Order Number", "unique": true },
        "customer": { "type": "reference", "ref": "customers", "label": "Customer" },
        "items": { "type": "grid", "label": "Order Items", "fields": {
          "product": { "type": "reference", "ref": "products" },
          "quantity": { "type": "number", "default": 1 },
          "price": { "type": "number" }
        }},
        "total": { "type": "number", "label": "Total Amount" },
        "status": { 
          "type": "select", 
          "label": "Status",
          "options": ["pending", "paid", "shipped", "completed", "cancelled"],
          "default": "pending"
        }
      }
    }
  }
}
```

## AI-Assisted UI Protocol Generation

### Prompt Template

```
I need to create ObjectUI protocol for [object name].

UI requirements:
- [UI requirement 1]
- [UI requirement 2]

Please generate JSON protocol compliant with ObjectStack ObjectUI specifications.
```

### Example Conversation

**User**:
```
I need to create a list page and detail form for the orders object.

UI requirements:
- List page displays order number, customer name, total amount, status
- Support filtering by status
- Clicking an order shows details
- Detail form can edit order status
```

**AI Response**:
```json
{
  "pages": {
    "order_list": {
      "type": "page",
      "title": "Order List",
      "components": [
        {
          "type": "table",
          "object": "orders",
          "columns": [
            { "field": "order_no", "label": "Order No" },
            { "field": "customer.name", "label": "Customer" },
            { "field": "total", "label": "Total" },
            { "field": "status", "label": "Status" }
          ],
          "filters": [
            { "field": "status", "type": "select", "label": "Status" }
          ],
          "actions": [
            { "type": "navigate", "target": "order_detail", "label": "View" }
          ]
        }
      ]
    },
    "order_detail": {
      "type": "page",
      "title": "Order Detail",
      "components": [
        {
          "type": "form",
          "object": "orders",
          "fields": [
            { "name": "order_no", "label": "Order No", "readonly": true },
            { "name": "customer", "label": "Customer", "readonly": true },
            { "name": "total", "label": "Total", "readonly": true },
            { "name": "status", "label": "Status", "type": "select" }
          ],
          "actions": [
            { "type": "submit", "label": "Save" }
          ]
        }
      ]
    }
  }
}
```

## AI-Assisted Plugin Development

### Prompt Template

```
I need to develop a server-side plugin for ObjectStack.

Functional requirements:
- [Requirement description]

Please generate code compliant with ObjectStack plugin specifications, including:
1. Plugin entry file
2. Necessary lifecycle hooks
3. Error handling
```

### Example Code Generation

**User**:
```
I need to develop a plugin that automatically sends email notifications after order creation.
```

**AI Response**:
```javascript
// plugins/order-notification.js
module.exports = {
  name: 'order-notification',
  
  hooks: {
    afterInsert: async (context, object, record) => {
      if (object === 'orders') {
        const { customer, total, order_no } = record;
        
        // Query customer email
        const customerData = await context.db.query({
          object: 'customers',
          filters: { _id: customer },
          fields: ['email', 'name']
        });
        
        if (customerData && customerData[0]?.email) {
          await context.email.send({
            to: customerData[0].email,
            subject: `Order Confirmation - ${order_no}`,
            body: `
              Dear ${customerData[0].name},
              
              Your order ${order_no} has been created successfully.
              Order amount: $${total}
              
              Thank you for your purchase!
            `
          });
        }
      }
    }
  }
};
```

## AI-Assisted Documentation Generation

### Auto-Generate API Documentation

Use TypeDoc or JSDoc to automatically generate documentation from code comments:

```typescript
/**
 * Query object data
 * @param {Object} options - Query options
 * @param {string} options.object - Object name
 * @param {Object} options.filters - Filter conditions
 * @param {Object} options.sort - Sort rules
 * @param {number} options.limit - Limit count
 * @returns {Promise<Array>} Query results
 * 
 * @example
 * const users = await db.query({
 *   object: 'users',
 *   filters: { age: { $gt: 18 } },
 *   sort: { created_at: 'desc' },
 *   limit: 10
 * });
 */
async function query(options) {
  // Implementation code
}
```

Then run:
```bash
npx typedoc --out docs/api src/
```

## Best Practices

### 1. Clear Context

When conversing with AI, clearly specify:
- Using ObjectStack concepts
- Protocol specifications to follow
- Target database type (if special requirements)

### 2. Provide Complete Information

Including:
- Detailed description of business requirements
- Relationships between data models
- UI interaction flows
- Special business rules

### 3. Validate Generated Code

AI-generated code needs:
- Verification of ObjectStack compliance
- Functional testing
- Security and performance review

### 4. Iterative Optimization

If results are not ideal:
- Provide more specific requirements
- Give examples or references
- Break down requirements step by step

## Recommended Tools

### Code Generation
- **GitHub Copilot**: Code completion and generation
- **ChatGPT / Claude**: Architecture design and problem solving
- **Cursor**: AI-assisted programming IDE

### Documentation Generation
- **TypeDoc**: TypeScript API documentation
- **JSDoc**: JavaScript API documentation
- **Swagger/OpenAPI**: REST API documentation

### Testing Assistance
- **AI-generated test cases**: Cover edge cases
- **AI code review**: Discover potential issues

## Considerations

### ⚠️ AI Limitations

- AI may generate code not compliant with latest specifications
- Manual verification of business logic correctness needed
- Complex architecture design still requires human decision-making

### ✅ AI Advantages

- Quickly generate repetitive code
- Provide multiple implementation options
- Assist documentation writing
- Code refactoring suggestions

## Summary

AI is a powerful assistant for ObjectStack development, but not a replacement. Best practices:

1. **Use AI to accelerate**: Schema definitions, UI protocols, repetitive code
2. **Manual review**: Business logic, security, performance optimization
3. **Continuous learning**: Understand AI capabilities and boundaries, use appropriately

By properly using AI tools, development efficiency can be improved 3-5x, allowing developers to focus more on core business logic.
