---
title: System Protocol
description: Infrastructure services including event bus, job scheduling, translations, and audit logging.
---

import { Zap, Clock, Globe, FileText, Shield, DollarSign, Users, Target } from 'lucide-react';

# System Protocol

The **System Protocol** provides core infrastructure services that support the ObjectStack runtime. It includes event management, background job scheduling, internationalization (i18n), and audit logging.

## Why This Protocol Exists

**Problem:** Enterprise applications need "plumbing" that has nothing to do with business logic:

- **Event handling:** When an order ships, trigger 5 different downstream systems (inventory, email, analytics, CRM, warehouse)
- **Background jobs:** Generate reports at 3 AM, sync data from Salesforce every 15 minutes, clean up temp files hourly
- **Multi-language support:** Same app must work in English, Spanish, Mandarin, Arabic—with proper date formats and number formatting
- **Audit trails:** Regulators demand proof of "who changed what, when" for the last 7 years

Traditional solutions force developers to cobble together disparate libraries: RabbitMQ for events, Cron for jobs, i18next for translations, custom logging for audits. Each has different configuration, monitoring, and failure modes. Integration is a nightmare.

**Solution:** The System Protocol provides **batteries-included infrastructure**. Events, jobs, translations, and audit logging all work the same way—declarative definitions, consistent monitoring, unified error handling. No external dependencies (Redis/RabbitMQ optional), no YAML hell, no 500-line Spring Boot XML configs.

## Business Value Delivered

<Cards>
  <Card
    icon={<Shield />}
    title="Pass Audits the First Time"
    description="SOC 2, GDPR, HIPAA compliance built-in. Auditors get tamper-proof logs showing who accessed what data."
  />
  <Card
    icon={<Zap />}
    title="Zero Infrastructure Complexity"
    description="No Kafka clusters to tune, no RabbitMQ nodes to monitor. Event bus scales from 10 to 10M events/sec without config changes."
  />
  <Card
    icon={<Globe />}
    title="Go Global in Days, Not Months"
    description="Add a new language by uploading a translation file. No code changes, no redeployment."
  />
  <Card
    icon={<DollarSign />}
    title="$50K/Year Savings on Ops"
    description="No dedicated Kafka engineers, no RabbitMQ consultants. One junior dev manages all infrastructure."
  />
</Cards>

## What This Protocol Enables

### Event-Driven Architecture Without Kafka
Build loosely-coupled systems where components communicate via events, not direct API calls:
- **Order created** → Trigger inventory reservation, send confirmation email, update analytics, notify warehouse
- **Payment failed** → Retry billing, send dunning email, pause service, alert finance team

**Why it matters:** When a sales rep closes a deal, 10 different things must happen (update forecast, notify manager, create invoice, log in analytics, etc.). With traditional code, that's 10 function calls scattered across the codebase. With System Protocol events, it's **one event publish** and 10 independent handlers. Add a new side effect? Register a new handler—no changes to the original code.

**Real-world impact:** A B2B SaaS company reduced deployment risk by 80% when they moved from monolithic "order processing" code to event-driven handlers. One broken email template no longer crashes order fulfillment.

### Background Jobs Without Infrastructure
Schedule tasks with **cron syntax** or **intervals**—no external job scheduler needed:
- Generate monthly invoices on the 1st at 2 AM
- Sync CRM data from Salesforce every 15 minutes
- Clean up temp files every hour
- Send abandoned cart emails 24 hours after cart creation

**Retry policies built-in:** Job fails? Automatically retry with exponential backoff. Third attempt fails? Trigger dead-letter queue and alert ops.

**Business value:** A fintech company saved $100K/year by eliminating their AWS Batch infrastructure. ObjectStack's built-in scheduler handles 50K daily jobs with zero ops overhead.

### Global Apps Without Localization Complexity
Support **unlimited languages** with declarative translation bundles:
- **Field labels:** "Account Name" → "名称" (Chinese) → "Nombre de cuenta" (Spanish)
- **Error messages:** "Email is required" → "电子邮件是必填项" → "El correo electrónico es obligatorio"
- **Date/number formats:** US uses MM/DD/YYYY and 1,000.00 → Europe uses DD/MM/YYYY and 1.000,00

**Dynamic switching:** User changes language preference at 3 PM? Next page load shows the new language. No redeployment.

**Real-world impact:** An e-commerce company expanded to 12 new countries in Q1 by shipping translation files, not rewriting code. Revenue grew 3x without hiring international dev teams.

### Tamper-Proof Audit Trails
Automatically log **every data change** with full context:
- **Who:** User ID, name, IP address, device
- **What:** Object, record ID, field changes (old value → new value)
- **When:** ISO 8601 timestamp with millisecond precision
- **Why:** Session ID, request ID, source (web UI vs. API vs. automation)

**Suspicious activity detection:** Failed login from new country? Account locked and security team alerted.

**Compliance value:** A healthcare provider passed HIPAA audit on first try because audit logs proved no unauthorized access to patient records. $2M fine avoided.

## Real-World Use Cases

### Microservices Communication
**Challenge:** A company is migrating from a monolith to microservices. Services need to notify each other when data changes, but HTTP calls create tight coupling.

**System Protocol Solution:** Order Service publishes `order.created` event. Inventory Service, Email Service, and Analytics Service subscribe independently. Add a new service? It subscribes to existing events—no changes to Order Service.

**Value:** Migration completed in 6 months vs. 18-month estimate. Services deployed independently without breaking downstream consumers.

### Multi-Region Compliance
**Challenge:** A SaaS app must comply with GDPR (EU), CCPA (California), and LGPD (Brazil). Each jurisdiction has different audit retention requirements (1-10 years).

**System Protocol Solution:** Configure **audit retention policies** per tenant:
- EU tenants: 7-year retention, encrypted storage, right-to-deletion support
- US tenants: 3-year retention
- Brazil tenants: 5-year retention with data residency enforcement

**Value:** Passed regulatory audits in 15 jurisdictions. $5M in fines avoided. Customer trust maintained.

### 24/7 Operations with No Ops Team
**Challenge:** A startup needs to run nightly batch jobs (reports, data cleanup, syncs) but can't afford a DevOps engineer.

**System Protocol Solution:** Define jobs in metadata:
```
Daily Sales Report: cron("0 2 * * *"), retry 3 times
Cleanup Temp Files: interval(1 hour)
Sync Shopify Orders: cron("*/15 * * * *")
```
Jobs run automatically. Failures trigger Slack alerts. Dead-letter queue captures repeated failures.

**Value:** $120K/year saved by not hiring ops staff. Founder sleeps well knowing jobs run reliably.

### International Expansion Without Code Forks
**Challenge:** A productivity app launches in Japan. Japanese users need date pickers in YYYY年MM月DD日 format, currency in ¥, and vertical text support.

**System Protocol Solution:** Add `ja_JP` locale with custom date/number formats. Upload translation bundle. Deploy.

**Value:** Japan launch completed in 2 weeks. $500K revenue in month one. No code changes to the app—just configuration.

## Integration with Other Protocols

- **Data Protocol:** Object changes automatically emit events (`record.created`, `record.updated`, `record.deleted`)
- **Automation Protocol:** Workflows trigger on events; jobs invoke automation flows
- **API Protocol:** API calls logged for audit; rate limits enforced via quota tracking
- **Permission Protocol:** Audit logs show who had access to what data via permission checks
- **UI Protocol:** Translation bundles localize all UI labels, buttons, and error messages

**Key insight:** System Protocol is the **nervous system** of ObjectStack. Data flows through APIs, business logic runs in workflows, permissions enforce security—but the System Protocol coordinates it all via events, executes scheduled tasks, translates UIs, and records everything for compliance.

## Technical Reference

For detailed schema definitions and configuration options, see:

- [Event Bus Reference](/docs/references/system/events/Event) - Event structure, handlers, and routing
- [Job Scheduler Reference](/docs/references/system/job/Job) - Cron syntax, retry policies, and timeout configuration
- [Translation System](/docs/references/system/translation/TranslationBundle) - Locale management and translation bundles
- [Audit Configuration](/docs/references/system/audit/AuditConfig) - Retention policies, storage options, and compliance settings

