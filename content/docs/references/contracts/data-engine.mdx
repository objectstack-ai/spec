---
title: Data Engine
description: Data Engine contract interface
---

# Data Engine

<Callout type="info">
**Source:** `packages/spec/src/contracts/data-engine.ts`
</Callout>

## Overview

The Data Engine contract defines the standard interface for data persistence capabilities in ObjectStack. It follows the Dependency Inversion Principle - plugins depend on this abstract interface, not on concrete database implementations.

## TypeScript Usage

```typescript
import type { IDataEngine, DriverInterface } from '@objectstack/spec/contracts';
import type { 
  DataEngineQueryOptions,
  DataEngineInsertOptions,
  DataEngineUpdateOptions,
  DataEngineDeleteOptions,
  QueryAST
} from '@objectstack/spec/data';

// Implement the Data Engine interface
class MyDataEngine implements IDataEngine {
  async find(objectName: string, query?: DataEngineQueryOptions): Promise<any[]> {
    // Implementation
  }
  
  async findOne(objectName: string, query?: DataEngineQueryOptions): Promise<any> {
    // Implementation
  }
  
  async insert(objectName: string, data: any | any[], options?: DataEngineInsertOptions): Promise<any> {
    // Implementation
  }
  
  // ... other methods
}
```

---

## IDataEngine

Standard Data Engine Interface for data persistence operations.

### Methods

#### `find(objectName: string, query?: DataEngineQueryOptions): Promise<any[]>`

Query multiple records from an object.

**Parameters:**
- `objectName` (string) - The name of the object to query
- `query` (DataEngineQueryOptions, optional) - Query options (filters, select, sort, pagination)

**Returns:** `Promise<any[]>` - Array of matching records

**Example:**
```typescript
const tasks = await dataEngine.find('project_task', {
  select: ['subject', 'priority', 'status'],
  filters: ['status', '=', 'active'],
  sort: ['-priority'],
  top: 10
});
```

---

#### `findOne(objectName: string, query?: DataEngineQueryOptions): Promise<any>`

Query a single record from an object.

**Parameters:**
- `objectName` (string) - The name of the object to query
- `query` (DataEngineQueryOptions, optional) - Query options

**Returns:** `Promise<any>` - The matching record or null

**Example:**
```typescript
const task = await dataEngine.findOne('project_task', {
  filters: ['_id', '=', 'task-123']
});
```

---

#### `insert(objectName: string, data: any | any[], options?: DataEngineInsertOptions): Promise<any>`

Insert one or more records.

**Parameters:**
- `objectName` (string) - The name of the object
- `data` (any | any[]) - Single record or array of records to insert
- `options` (DataEngineInsertOptions, optional) - Insert options

**Returns:** `Promise<any>` - The created record(s)

**Example:**
```typescript
// Insert single record
const task = await dataEngine.insert('project_task', {
  subject: 'New task',
  priority: 1,
  status: 'active'
});

// Insert multiple records
const tasks = await dataEngine.insert('project_task', [
  { subject: 'Task 1', priority: 1 },
  { subject: 'Task 2', priority: 2 }
]);
```

---

#### `update(objectName: string, data: any, options?: DataEngineUpdateOptions): Promise<any>`

Update a record.

**Parameters:**
- `objectName` (string) - The name of the object
- `data` (any) - Record data with _id or update criteria
- `options` (DataEngineUpdateOptions, optional) - Update options

**Returns:** `Promise<any>` - The updated record

**Example:**
```typescript
const updatedTask = await dataEngine.update('project_task', {
  _id: 'task-123',
  status: 'completed'
});
```

---

#### `delete(objectName: string, options?: DataEngineDeleteOptions): Promise<any>`

Delete one or more records.

**Parameters:**
- `objectName` (string) - The name of the object
- `options` (DataEngineDeleteOptions, optional) - Delete options (filters, _id)

**Returns:** `Promise<any>` - Deletion result

**Example:**
```typescript
// Delete by ID
await dataEngine.delete('project_task', {
  filters: ['_id', '=', 'task-123']
});

// Delete multiple
await dataEngine.delete('project_task', {
  filters: ['status', '=', 'completed']
});
```

---

#### `count(objectName: string, query?: DataEngineCountOptions): Promise<number>`

Count records matching criteria.

**Parameters:**
- `objectName` (string) - The name of the object
- `query` (DataEngineCountOptions, optional) - Count options (filters)

**Returns:** `Promise<number>` - Number of matching records

**Example:**
```typescript
const activeTaskCount = await dataEngine.count('project_task', {
  filters: ['status', '=', 'active']
});
```

---

#### `aggregate(objectName: string, query: DataEngineAggregateOptions): Promise<any[]>`

Perform aggregation queries.

**Parameters:**
- `objectName` (string) - The name of the object
- `query` (DataEngineAggregateOptions) - Aggregation options (groupBy, aggregations)

**Returns:** `Promise<any[]>` - Aggregation results

**Example:**
```typescript
const taskStats = await dataEngine.aggregate('project_task', {
  groupBy: ['status'],
  aggregations: [
    { field: '_id', function: 'count', alias: 'total' },
    { field: 'priority', function: 'avg', alias: 'avg_priority' }
  ]
});
```

---

### Optional Methods

#### `vectorFind?(objectName: string, vector: number[], options?): Promise<any[]>`

Vector similarity search for AI/RAG applications.

**Parameters:**
- `objectName` (string) - The name of the object
- `vector` (number[]) - Query vector
- `options` (object, optional)
  - `filter` (any, optional) - Additional filters
  - `limit` (number, optional) - Max results
  - `select` (string[], optional) - Fields to return
  - `threshold` (number, optional) - Similarity threshold

**Returns:** `Promise<any[]>` - Similar records

**Example:**
```typescript
const similarDocs = await dataEngine.vectorFind('knowledge_base', queryVector, {
  limit: 5,
  threshold: 0.8
});
```

---

#### `batch?(requests: DataEngineRequest[], options?): Promise<any[]>`

Execute multiple operations in a batch, optionally with transaction support.

**Parameters:**
- `requests` (DataEngineRequest[]) - Array of operations
- `options` (object, optional)
  - `transaction` (boolean, optional) - Execute in transaction

**Returns:** `Promise<any[]>` - Results for each operation

**Example:**
```typescript
const results = await dataEngine.batch([
  { operation: 'insert', object: 'project_task', data: {...} },
  { operation: 'update', object: 'project', data: {...} }
], { transaction: true });
```

---

#### `execute?(command: any, options?): Promise<any>`

Execute raw database command (escape hatch).

**Parameters:**
- `command` (any) - Database-specific command
- `options` (`Record<string, any>`, optional) - Command options

**Returns:** `Promise<any>` - Command result

**Warning:** Use sparingly - this breaks abstraction.

---

## DriverInterface

Low-level driver interface for database implementations.

### Properties

- `name` (string) - Driver name
- `version` (string) - Driver version

### Methods

#### Core CRUD Operations

- `connect(): Promise<void>` - Establish database connection
- `disconnect(): Promise<void>` - Close database connection
- `find(object: string, query: QueryAST, options?: DriverOptions): Promise<any[]>` - Query records
- `findOne(object: string, query: QueryAST, options?: DriverOptions): Promise<any>` - Query single record
- `create(object: string, data: any, options?: DriverOptions): Promise<any>` - Create record
- `update(object: string, id: any, data: any, options?: DriverOptions): Promise<any>` - Update record
- `delete(object: string, id: any, options?: DriverOptions): Promise<any>` - Delete record

#### Optional Bulk Operations

- `bulkCreate?(object: string, data: any[], options?: DriverOptions): Promise<any>` - Bulk insert
- `updateMany?(object: string, query: QueryAST, data: any, options?: DriverOptions): Promise<any>` - Bulk update
- `deleteMany?(object: string, query: QueryAST, options?: DriverOptions): Promise<any>` - Bulk delete
- `count?(object: string, query: QueryAST, options?: DriverOptions): Promise<number>` - Count records

#### Raw Execution

- `execute?(command: any, params?: any, options?: DriverOptions): Promise<any>` - Execute raw command

---

## Implementation Example

```typescript
import type { IDataEngine } from '@objectstack/spec/contracts';

class PostgresDataEngine implements IDataEngine {
  constructor(private pool: Pool) {}
  
  async find(objectName: string, query?: DataEngineQueryOptions): Promise<any[]> {
    const sql = this.buildSelectSQL(objectName, query);
    const result = await this.pool.query(sql);
    return result.rows;
  }
  
  async insert(objectName: string, data: any): Promise<any> {
    const sql = this.buildInsertSQL(objectName, data);
    const result = await this.pool.query(sql);
    return result.rows[0];
  }
  
  // ... other implementations
  
  private buildSelectSQL(objectName: string, query?: DataEngineQueryOptions): string {
    // SQL building logic
  }
}
```

---

## Best Practices

1. **Use the abstraction**: Depend on IDataEngine, not concrete implementations
2. **Handle errors gracefully**: Wrap database errors in consistent error types
3. **Support transactions**: Implement batch operations with transaction support when possible
4. **Optimize queries**: Use indexes and query optimization for better performance
5. **Test thoroughly**: Test with different drivers to ensure compatibility
6. **Document limitations**: Clearly document which optional methods are supported
