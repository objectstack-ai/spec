---
title: Plugin Validator
description: Plugin Validator contract interface
---

# Plugin Validator

<Callout type="info">
**Source:** `packages/spec/src/contracts/plugin-validator.ts`
</Callout>

## Overview

The Plugin Validator contract defines the interface for validating plugins before registration and startup. It follows the Single Responsibility Principle by separating validation logic from plugin loading.

## TypeScript Usage

```typescript
import type { IPluginValidator, Plugin, ValidationResult } from '@objectstack/spec/contracts';

// Implement the Plugin Validator interface
class MyPluginValidator implements IPluginValidator {
  validate(plugin: unknown): ValidationResult {
    // Validation logic
    return {
      valid: true,
      errors: [],
      warnings: []
    };
  }
  
  validateVersion(version: string): boolean {
    // Version validation logic
    return /^\d+\.\d+\.\d+/.test(version);
  }
  
  validateSignature(plugin: Plugin, signature: string): boolean {
    // Signature validation logic
    return true;
  }
}
```

---

## ValidationResult

Result of plugin validation.

**Properties:**
- `valid` (boolean) - Whether the plugin passed validation
- `errors` (Array, optional) - Validation errors (if any)
  - `field` (string) - Field that failed validation
  - `message` (string) - Error message
  - `code` (string, optional) - Error code
- `warnings` (Array, optional) - Validation warnings (non-fatal issues)
  - `field` (string) - Field with warning
  - `message` (string) - Warning message
  - `code` (string, optional) - Warning code

**Example:**
```typescript
const result: ValidationResult = {
  valid: false,
  errors: [
    {
      field: 'name',
      message: 'Plugin name is required',
      code: 'MISSING_NAME'
    }
  ],
  warnings: [
    {
      field: 'version',
      message: 'Version format recommended: x.y.z',
      code: 'VERSION_FORMAT'
    }
  ]
};
```

---

## Plugin

Plugin metadata for validation.

**Properties:**
- `name` (string) - Unique plugin identifier
- `version` (string, optional) - Plugin version (semver)
- `dependencies` (string[], optional) - Plugin dependencies
- `init` (function, optional) - Plugin initialization function
  - Signature: `(context: any) => void | Promise<void>`
- `start` (function, optional) - Plugin startup function
  - Signature: `(context: any) => void | Promise<void>`
- `destroy` (function, optional) - Plugin destruction function
  - Signature: `(context: any) => void | Promise<void>`
- `signature` (string, optional) - Plugin signature for verification
- Additional properties allowed via index signature

**Example:**
```typescript
const plugin: Plugin = {
  name: '@myorg/my-plugin',
  version: '1.0.0',
  dependencies: ['@objectstack/core'],
  init: async (context) => {
    console.log('Initializing plugin');
  },
  start: async (context) => {
    console.log('Starting plugin');
  },
  destroy: async (context) => {
    console.log('Destroying plugin');
  }
};
```

---

## IPluginValidator

Plugin validation interface.

### Methods

#### `validate(plugin: unknown): ValidationResult`

Validate a plugin object structure.

**Parameters:**
- `plugin` (unknown) - Plugin to validate

**Returns:** ValidationResult - Validation result with errors/warnings

**Example:**
```typescript
const validator = new MyPluginValidator();
const result = validator.validate({
  name: '@myorg/plugin',
  version: '1.0.0'
});

if (!result.valid) {
  console.error('Validation failed:', result.errors);
}
```

---

#### `validateVersion(version: string): boolean`

Validate plugin version format (semver).

**Parameters:**
- `version` (string) - Version string to validate

**Returns:** boolean - True if version is valid, false otherwise

**Example:**
```typescript
const validator = new MyPluginValidator();

console.log(validator.validateVersion('1.0.0')); // true
console.log(validator.validateVersion('1.0'));   // false
console.log(validator.validateVersion('v1.0.0')); // true (with prefix)
```

---

#### `validateSignature(plugin: Plugin, signature: string): boolean`

Validate plugin cryptographic signature (optional security feature).

**Parameters:**
- `plugin` (Plugin) - Plugin to validate
- `signature` (string) - Cryptographic signature

**Returns:** boolean - True if signature is valid, false otherwise

**Example:**
```typescript
const validator = new MyPluginValidator();
const plugin = {
  name: '@myorg/plugin',
  version: '1.0.0',
  signature: 'sha256:abc123...'
};

const isValid = validator.validateSignature(plugin, plugin.signature);
```

---

## Implementation Example

### Basic Validator

```typescript
import type { IPluginValidator, Plugin, ValidationResult } from '@objectstack/spec/contracts';

class BasicPluginValidator implements IPluginValidator {
  validate(plugin: unknown): ValidationResult {
    const errors: ValidationResult['errors'] = [];
    const warnings: ValidationResult['warnings'] = [];
    
    // Type check
    if (typeof plugin !== 'object' || plugin === null) {
      return {
        valid: false,
        errors: [{ field: 'plugin', message: 'Plugin must be an object' }]
      };
    }
    
    const p = plugin as Partial<Plugin>;
    
    // Required fields
    if (!p.name || typeof p.name !== 'string') {
      errors.push({
        field: 'name',
        message: 'Plugin name is required and must be a string',
        code: 'MISSING_NAME'
      });
    }
    
    // Version validation
    if (p.version && !this.validateVersion(p.version)) {
      errors.push({
        field: 'version',
        message: 'Invalid version format. Use semver (x.y.z)',
        code: 'INVALID_VERSION'
      });
    }
    
    // Lifecycle methods
    if (p.init && typeof p.init !== 'function') {
      errors.push({
        field: 'init',
        message: 'init must be a function',
        code: 'INVALID_INIT'
      });
    }
    
    if (p.start && typeof p.start !== 'function') {
      errors.push({
        field: 'start',
        message: 'start must be a function',
        code: 'INVALID_START'
      });
    }
    
    if (p.destroy && typeof p.destroy !== 'function') {
      errors.push({
        field: 'destroy',
        message: 'destroy must be a function',
        code: 'INVALID_DESTROY'
      });
    }
    
    // Dependencies check
    if (p.dependencies) {
      if (!Array.isArray(p.dependencies)) {
        errors.push({
          field: 'dependencies',
          message: 'dependencies must be an array',
          code: 'INVALID_DEPENDENCIES'
        });
      } else if (p.dependencies.some(d => typeof d !== 'string')) {
        errors.push({
          field: 'dependencies',
          message: 'All dependencies must be strings',
          code: 'INVALID_DEPENDENCY_TYPE'
        });
      }
    }
    
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }
  
  validateVersion(version: string): boolean {
    // Semver regex: x.y.z with optional v prefix and pre-release
    const semverRegex = /^v?(\d+)\.(\d+)\.(\d+)(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
    return semverRegex.test(version);
  }
  
  validateSignature(plugin: Plugin, signature: string): boolean {
    // Placeholder - implement cryptographic verification
    // This would verify the plugin code against the signature
    return signature.startsWith('sha256:');
  }
}
```

### Advanced Validator with Security

```typescript
import crypto from 'crypto';
import type { IPluginValidator, Plugin, ValidationResult } from '@objectstack/spec/contracts';

class SecurePluginValidator implements IPluginValidator {
  constructor(
    private trustedPublicKeys: Map<string, string> = new Map()
  ) {}
  
  validate(plugin: unknown): ValidationResult {
    const basicResult = this.basicValidation(plugin);
    if (!basicResult.valid) {
      return basicResult;
    }
    
    const p = plugin as Plugin;
    const warnings: ValidationResult['warnings'] = [];
    
    // Security checks
    if (!p.signature) {
      warnings.push({
        field: 'signature',
        message: 'Plugin is not signed. This may pose a security risk.',
        code: 'MISSING_SIGNATURE'
      });
    }
    
    // Check for suspicious patterns
    if (this.hasSuspiciousCode(p)) {
      warnings.push({
        field: 'code',
        message: 'Plugin contains potentially suspicious code patterns',
        code: 'SUSPICIOUS_CODE'
      });
    }
    
    return {
      valid: true,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }
  
  validateVersion(version: string): boolean {
    const semverRegex = /^v?(\d+)\.(\d+)\.(\d+)(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
    return semverRegex.test(version);
  }
  
  validateSignature(plugin: Plugin, signature: string): boolean {
    if (!signature || !plugin.name) {
      return false;
    }
    
    // Get public key for this plugin
    const publicKey = this.trustedPublicKeys.get(plugin.name);
    if (!publicKey) {
      return false;
    }
    
    try {
      // Verify signature (simplified example)
      const verify = crypto.createVerify('SHA256');
      verify.update(JSON.stringify(plugin));
      verify.end();
      
      return verify.verify(publicKey, signature, 'hex');
    } catch (error) {
      return false;
    }
  }
  
  private basicValidation(plugin: unknown): ValidationResult {
    // Reuse basic validation logic
    return { valid: true };
  }
  
  private hasSuspiciousCode(plugin: Plugin): boolean {
    // Check for dangerous patterns
    const suspiciousPatterns = [
      'eval(',
      'Function(',
      'require.cache',
      'process.exit'
    ];
    
    const pluginStr = JSON.stringify(plugin);
    return suspiciousPatterns.some(pattern => pluginStr.includes(pattern));
  }
  
  addTrustedKey(pluginName: string, publicKey: string): void {
    this.trustedPublicKeys.set(pluginName, publicKey);
  }
}
```

---

## Use Cases

### 1. Plugin Registry Validation

```typescript
const validator = new BasicPluginValidator();

function registerPlugin(plugin: unknown) {
  const result = validator.validate(plugin);
  
  if (!result.valid) {
    throw new Error(`Plugin validation failed: ${
      result.errors?.map(e => e.message).join(', ')
    }`);
  }
  
  if (result.warnings) {
    console.warn('Plugin warnings:', result.warnings);
  }
  
  // Proceed with registration
  registry.add(plugin as Plugin);
}
```

### 2. Marketplace Plugin Verification

```typescript
const secureValidator = new SecurePluginValidator();

async function installMarketplacePlugin(pluginData: unknown) {
  // Validate structure
  const result = secureValidator.validate(pluginData);
  if (!result.valid) {
    throw new Error('Invalid plugin structure');
  }
  
  const plugin = pluginData as Plugin;
  
  // Verify signature
  if (plugin.signature && !secureValidator.validateSignature(plugin, plugin.signature)) {
    throw new Error('Plugin signature verification failed');
  }
  
  // Install plugin
  await installPlugin(plugin);
}
```

### 3. Development Plugin Hot Reload

```typescript
const devValidator = new BasicPluginValidator();

function reloadPlugin(pluginPath: string) {
  const plugin = require(pluginPath);
  
  const result = devValidator.validate(plugin);
  
  if (!result.valid) {
    console.error('Plugin reload failed:', result.errors);
    return false;
  }
  
  if (result.warnings) {
    console.warn('Plugin warnings:', result.warnings);
  }
  
  // Hot reload the plugin
  hotReload(plugin);
  return true;
}
```

---

## Best Practices

1. **Validate early**: Validate plugins before loading or registration
2. **Clear error messages**: Provide actionable error messages with field context
3. **Use error codes**: Include error codes for programmatic handling
4. **Security first**: Implement signature validation for production plugins
5. **Graceful warnings**: Use warnings for non-critical issues
6. **Semver compliance**: Enforce semantic versioning for compatibility
7. **Test validation**: Write comprehensive tests for edge cases
8. **Document requirements**: Clearly document what makes a valid plugin
